{"version":3,"sources":["resources/factoryCode/typescript-next.ts"],"names":["generateFactoryCode","ts","initialNode","writer","CodeBlockWriter","newLine","indentNumberOfSpaces","syntaxKindToName","map","Object","keys","SyntaxKind","filter","k","isNaN","parseInt","name","value","createSyntaxKindToNameMap","isSourceFile","write","statements","length","indent","i","statement","writeNodeText","newLineIfLastNot","toString","node","kind","NumericLiteral","quote","text","createNumericLiteral","BigIntLiteral","createBigIntLiteral","StringLiteral","createStringLiteral","RegularExpressionLiteral","createRegularExpressionLiteral","Identifier","createIdentifier","PrivateIdentifier","createPrivateIdentifier","SuperKeyword","ThisKeyword","NullKeyword","TrueKeyword","FalseKeyword","QualifiedName","left","right","createQualifiedName","ComputedPropertyName","expression","createComputedPropertyName","TypeParameter","constraint","writeNodeTextForTypeNode","default","createTypeParameterDeclaration","Parameter","decorators","item","modifiers","dotDotDotToken","questionToken","type","initializer","createParameterDeclaration","Decorator","createDecorator","PropertySignature","createPropertySignature","PropertyDeclaration","exclamationToken","createPropertyDeclaration","MethodSignature","typeParameters","parameters","createMethodSignature","MethodDeclaration","asteriskToken","body","createMethodDeclaration","Constructor","createConstructorDeclaration","GetAccessor","createGetAccessorDeclaration","SetAccessor","createSetAccessorDeclaration","CallSignature","createCallSignature","ConstructSignature","createConstructSignature","IndexSignature","createIndexSignature","TemplateLiteralTypeSpan","literal","createTemplateLiteralTypeSpan","ClassStaticBlockDeclaration","createClassStaticBlockDeclaration","AnyKeyword","BooleanKeyword","IntrinsicKeyword","NeverKeyword","NumberKeyword","ObjectKeyword","StringKeyword","SymbolKeyword","UndefinedKeyword","UnknownKeyword","BigIntKeyword","createKeywordTypeNode","TypeReference","typeName","typeArguments","createTypeReferenceNode","FunctionType","createFunctionTypeNode","ConstructorType","createConstructorTypeNode","TypeQuery","exprName","createTypeQueryNode","TypeLiteral","members","createTypeLiteralNode","ArrayType","elementType","createArrayTypeNode","TupleType","elements","createTupleTypeNode","NamedTupleMember","createNamedTupleMember","OptionalType","createOptionalTypeNode","RestType","createRestTypeNode","UnionType","types","createUnionTypeNode","IntersectionType","createIntersectionTypeNode","ConditionalType","checkType","extendsType","trueType","falseType","createConditionalTypeNode","InferType","typeParameter","createInferTypeNode","ImportType","argument","qualifier","isTypeOf","createImportTypeNode","ParenthesizedType","createParenthesizedType","ThisType","TypeOperator","operator","createTypeOperatorNode","IndexedAccessType","objectType","indexType","createIndexedAccessTypeNode","MappedType","readonlyToken","nameType","createMappedTypeNode","LiteralType","createLiteralTypeNode","TemplateLiteralType","head","templateSpans","createTemplateLiteralType","ObjectBindingPattern","createObjectBindingPattern","ArrayBindingPattern","createArrayBindingPattern","BindingElement","propertyName","createBindingElement","ArrayLiteralExpression","multiLine","createArrayLiteralExpression","ObjectLiteralExpression","properties","createObjectLiteralExpression","PropertyAccessExpression","isPropertyAccessChain","questionDotToken","createPropertyAccessChain","isPropertyAccessExpression","createPropertyAccessExpression","Error","getText","ElementAccessExpression","isElementAccessChain","argumentExpression","createElementAccessChain","isElementAccessExpression","createElementAccessExpression","CallExpression","isCallChain","arguments","createCallChain","isCallExpression","createCallExpression","NewExpression","createNewExpression","TaggedTemplateExpression","tag","template","createTaggedTemplateExpression","TypeAssertionExpression","createTypeAssertion","ParenthesizedExpression","createParenthesizedExpression","FunctionExpression","createFunctionExpression","ArrowFunction","equalsGreaterThanToken","createArrowFunction","DeleteExpression","createDeleteExpression","TypeOfExpression","createTypeOfExpression","VoidExpression","createVoidExpression","AwaitExpression","createAwaitExpression","PrefixUnaryExpression","operand","createPrefixUnaryExpression","PostfixUnaryExpression","createPostfixUnaryExpression","BinaryExpression","operatorToken","createBinaryExpression","ConditionalExpression","condition","whenTrue","colonToken","whenFalse","createConditionalExpression","TemplateExpression","createTemplateExpression","TemplateHead","rawText","createTemplateHead","TemplateMiddle","createTemplateMiddle","TemplateTail","createTemplateTail","NoSubstitutionTemplateLiteral","createNoSubstitutionTemplateLiteral","YieldExpression","createYieldExpression","SpreadElement","createSpreadElement","ClassExpression","heritageClauses","createClassExpression","OmittedExpression","ExpressionWithTypeArguments","createExpressionWithTypeArguments","AsExpression","createAsExpression","NonNullExpression","isNonNullChain","createNonNullChain","isNonNullExpression","createNonNullExpression","MetaProperty","keywordToken","createMetaProperty","TemplateSpan","createTemplateSpan","SemicolonClassElement","Block","createBlock","VariableStatement","declarationList","createVariableStatement","EmptyStatement","ExpressionStatement","createExpressionStatement","IfStatement","thenStatement","elseStatement","createIfStatement","DoStatement","createDoStatement","WhileStatement","createWhileStatement","ForStatement","incrementor","createForStatement","ForInStatement","createForInStatement","ForOfStatement","awaitModifier","createForOfStatement","ContinueStatement","label","createContinueStatement","BreakStatement","createBreakStatement","ReturnStatement","createReturnStatement","WithStatement","createWithStatement","SwitchStatement","caseBlock","createSwitchStatement","LabeledStatement","createLabeledStatement","ThrowStatement","createThrowStatement","TryStatement","tryBlock","catchClause","finallyBlock","createTryStatement","DebuggerStatement","VariableDeclaration","createVariableDeclaration","VariableDeclarationList","declarations","getNodeFlagValues","flags","createVariableDeclarationList","FunctionDeclaration","createFunctionDeclaration","ClassDeclaration","createClassDeclaration","InterfaceDeclaration","createInterfaceDeclaration","TypeAliasDeclaration","createTypeAliasDeclaration","EnumDeclaration","createEnumDeclaration","ModuleDeclaration","createModuleDeclaration","ModuleBlock","createModuleBlock","CaseBlock","clauses","createCaseBlock","NamespaceExportDeclaration","createNamespaceExportDeclaration","ImportEqualsDeclaration","isTypeOnly","moduleReference","createImportEqualsDeclaration","ImportDeclaration","importClause","moduleSpecifier","assertClause","createImportDeclaration","ImportClause","namedBindings","createImportClause","AssertClause","createAssertClause","AssertEntry","createAssertEntry","NamespaceImport","createNamespaceImport","NamespaceExport","createNamespaceExport","NamedImports","createNamedImports","ImportSpecifier","createImportSpecifier","ExportAssignment","isExportEquals","createExportAssignment","ExportDeclaration","exportClause","createExportDeclaration","NamedExports","createNamedExports","ExportSpecifier","createExportSpecifier","ExternalModuleReference","createExternalModuleReference","JsxElement","openingElement","children","closingElement","createJsxElement","JsxSelfClosingElement","tagName","attributes","createJsxSelfClosingElement","JsxOpeningElement","createJsxOpeningElement","JsxClosingElement","createJsxClosingElement","JsxFragment","openingFragment","closingFragment","createJsxFragment","JsxText","containsOnlyTriviaWhiteSpaces","createJsxText","JsxOpeningFragment","JsxClosingFragment","JsxAttribute","createJsxAttribute","JsxAttributes","createJsxAttributes","JsxSpreadAttribute","createJsxSpreadAttribute","JsxExpression","createJsxExpression","CaseClause","createCaseClause","DefaultClause","createDefaultClause","HeritageClause","token","createHeritageClause","CatchClause","variableDeclaration","block","createCatchClause","PropertyAssignment","createPropertyAssignment","ShorthandPropertyAssignment","objectAssignmentInitializer","createShorthandPropertyAssignment","SpreadAssignment","createSpreadAssignment","EnumMember","createEnumMember","CommaListExpression","createCommaListExpression","FirstToken","LastToken","FirstKeyword","LastKeyword","enumObj","enumName","defaultName","flagValues","getFlagValues","flagValue","push","join","getFlagValuesAsString","NodeFlags","v","BlockScoped","prop"],"mappings":"gNAEO,SAASA,EAAoBC,EAAsCC,GACtE,IAAMC,EAAS,IAAIC,IAAgB,CAAEC,QAAS,KAAMC,qBAAsB,IACpEC,EA65IN,WACI,IADiC,EAC3BC,EAAkC,GADP,cAEdC,OAAOC,KAAKT,EAAGU,YAAYC,QAAO,SAAAC,GAAC,OAAIC,MAAMC,SAASF,EAAG,SAF3C,IAEjC,2BAAmF,CAAC,IAAzEG,EAAwE,QACzEC,EAAShB,EAAGU,WAAmBK,GACnB,MAAdR,EAAIS,KACJT,EAAIS,GAASD,IALY,8BAOjC,OAAOR,EAp6IcU,GAqBzB,OAnBIjB,EAAGkB,aAAajB,IAChBC,EAAOiB,MAAM,KACTlB,EAAYmB,WAAWC,OAAS,GAChCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAItB,EAAYmB,WAAWC,OAAQE,IAAK,CACpD,IAAMC,EAAYvB,EAAYmB,WAAWG,GACrCA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcD,OAEnBpB,UAEPF,EAAOiB,MAAM,OAGbM,EAAcxB,GAElBC,EAAOwB,mBAEAxB,EAAOyB,WAEd,SAASF,EAAcG,GACnB,OAAQA,EAAKC,MACT,KAAK7B,EAAGU,WAAWoB,eAEf,YAqhBZ,SAA8BF,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAzhBLc,CAAqBL,GAEzB,KAAK5B,EAAGU,WAAWwB,cAEf,YAwhBZ,SAA6BN,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KA5hBLgB,CAAoBP,GAExB,KAAK5B,EAAGU,WAAW0B,cAEf,YA2hBZ,SAA6BR,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KA/hBLkB,CAAoBT,GAExB,KAAK5B,EAAGU,WAAW4B,yBAEf,YA8hBZ,SAAwCV,GACpC1B,EAAOiB,MAAM,2CACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAliBLoB,CAA+BX,GAEnC,KAAK5B,EAAGU,WAAW8B,WAEf,YAiiBZ,SAA0BZ,GACtB1B,EAAOiB,MAAM,6BACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAriBLsB,CAAiBb,GAErB,KAAK5B,EAAGU,WAAWgC,kBAEf,YAoiBZ,SAAiCd,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAxiBLwB,CAAwBf,GAE5B,KAAK5B,EAAGU,WAAWkC,aAEf,OAwiBR1C,EAAOiB,MAAM,6BACbjB,EAAOiB,MAAM,KAxiBT,KAAKnB,EAAGU,WAAWmC,YAEf,OA0iBR3C,EAAOiB,MAAM,4BACbjB,EAAOiB,MAAM,KA1iBT,KAAKnB,EAAGU,WAAWoC,YAEf,OA4iBR5C,EAAOiB,MAAM,4BACbjB,EAAOiB,MAAM,KA5iBT,KAAKnB,EAAGU,WAAWqC,YAEf,OA8iBR7C,EAAOiB,MAAM,4BACbjB,EAAOiB,MAAM,KA9iBT,KAAKnB,EAAGU,WAAWsC,aAEf,OAgjBR9C,EAAOiB,MAAM,6BACbjB,EAAOiB,MAAM,KAhjBT,KAAKnB,EAAGU,WAAWuC,cAEf,YAijBZ,SAA6BrB,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKsB,MACnBhD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKuB,UAEvBjD,EAAOiB,MAAM,KA1jBLiC,CAAoBxB,GAExB,KAAK5B,EAAGU,WAAW2C,qBAEf,YAyjBZ,SAAoCzB,GAChC1B,EAAOiB,MAAM,uCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA7jBLoC,CAA2B3B,GAE/B,KAAK5B,EAAGU,WAAW8C,cAEf,YA4jBZ,SAAwC5B,GACpC1B,EAAOiB,MAAM,2CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACK,MAAnBwB,EAAK6B,WACLvD,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAK6B,YAElCvD,EAAOiB,MAAM,KAAKf,UACE,MAAhBwB,EAAK+B,QACLzD,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAK+B,YAGtCzD,EAAOiB,MAAM,KA/kBLyC,CAA+BhC,GAEnC,KAAK5B,EAAGU,WAAWmD,UAEf,YA8kBZ,SAAoCjC,GAChC1B,EAAOiB,MAAM,uCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKqC,eACL/D,EAAOiB,MAAM,aAEbM,EAAcG,EAAKqC,gBAEvB/D,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KAvpBLkD,CAA2BzC,GAE/B,KAAK5B,EAAGU,WAAW4D,UAEf,YAspBZ,SAAyB1C,GACrB1B,EAAOiB,MAAM,4BACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA1pBLoD,CAAgB3C,GAEpB,KAAK5B,EAAGU,WAAW8D,kBAEf,YAypBZ,SAAiC5C,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,SAGtCjE,EAAOiB,MAAM,KAjsBLsD,CAAwB7C,GAE5B,KAAK5B,EAAGU,WAAWgE,oBAEf,YAgsBZ,SAAmC9C,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,oDACiB,MAAzBS,EAAK+C,iBACVzE,EAAOiB,MAAM,uDAEbjB,EAAOiB,MAAM,aACjBjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KApwBLyD,CAA0BhD,GAE9B,KAAK5B,EAAGU,WAAWmE,gBAEf,YAmwBZ,SAA+BjD,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAWjB,GATAjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,SAGtCjE,EAAOiB,MAAM,KAj1BL6D,CAAsBpD,GAE1B,KAAK5B,EAAGU,WAAWuE,kBAEf,YAg1BZ,SAAiCrD,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAiBjB,GAfAjB,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsD,cACLhF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsD,eAEvBhF,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,SAG3BjF,EAAOiB,MAAM,KA/7BLiE,CAAwBxD,GAE5B,KAAK5B,EAAGU,WAAW2E,YAEf,YA87BZ,SAAsCzD,GAClC1B,EAAOiB,MAAM,yCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,SAG3BjF,EAAOiB,MAAM,KApgCLmE,CAA6B1D,GAEjC,KAAK5B,EAAGU,WAAW6E,YAEf,YAmgCZ,SAAsC3D,GAClC1B,EAAOiB,MAAM,yCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,SAG3BjF,EAAOiB,MAAM,KAjlCLqE,CAA6B5D,GAEjC,KAAK5B,EAAGU,WAAW+E,YAEf,YAglCZ,SAAsC7D,GAClC1B,EAAOiB,MAAM,yCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,SAG3BjF,EAAOiB,MAAM,KAxpCLuE,CAA6B9D,GAEjC,KAAK5B,EAAGU,WAAWiF,cAEf,YAupCZ,SAA6B/D,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAA2B,MAAvBM,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,SAGtCjE,EAAOiB,MAAM,KAxsCLyE,CAAoBhE,GAExB,KAAK5B,EAAGU,WAAWmF,mBAEf,YAusCZ,SAAkCjE,GAC9B1B,EAAOiB,MAAM,qCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAA2B,MAAvBM,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,SAGtCjE,EAAOiB,MAAM,KAxvCL2E,CAAyBlE,GAE7B,KAAK5B,EAAGU,WAAWqF,eAEf,YAuvCZ,SAA8BnE,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KAzzCL6E,CAAqBpE,GAEzB,KAAK5B,EAAGU,WAAWuF,wBAEf,YAwzCZ,SAAuCrE,GACnC1B,EAAOiB,MAAM,0CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVoC,EAAyB9B,EAAKuC,MAC9BjE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKsE,YAEvBhG,EAAOiB,MAAM,KAj0CLgF,CAA8BvE,GAElC,KAAK5B,EAAGU,WAAW0F,4BAEf,YAg0CZ,SAA2CxE,GACvC1B,EAAOiB,MAAM,8CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKuD,SAEvBjF,EAAOiB,MAAM,KAj3CLkF,CAAkCzE,GAEtC,KAAK5B,EAAGU,WAAW4F,WAGnB,KAAKtG,EAAGU,WAAW6F,eAGnB,KAAKvG,EAAGU,WAAW8F,iBAGnB,KAAKxG,EAAGU,WAAW+F,aAGnB,KAAKzG,EAAGU,WAAWgG,cAGnB,KAAK1G,EAAGU,WAAWiG,cAGnB,KAAK3G,EAAGU,WAAWkG,cAGnB,KAAK5G,EAAGU,WAAWmG,cAGnB,KAAK7G,EAAGU,WAAWoG,iBAGnB,KAAK9G,EAAGU,WAAWqG,eAGnB,KAAK/G,EAAGU,WAAWsG,cAEf,YADAC,EAAsBrF,GAE1B,KAAK5B,EAAGU,WAAWwG,cAEf,YAq1CZ,SAAiCtF,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAKuF,UACnBjH,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,SAGrBjB,EAAOiB,MAAM,KAj3CLkG,CAAwBzF,GAE5B,KAAK5B,EAAGU,WAAW4G,aAEf,YAg3CZ,SAAgC1F,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAA2B,MAAvBM,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KA75CLoG,CAAuB3F,GAE3B,KAAK5B,EAAGU,WAAW8G,gBAEf,YA45CZ,SAAmC5F,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KA99CLsG,CAA0B7F,GAE9B,KAAK5B,EAAGU,WAAWgH,UAEf,YA69CZ,SAA6B9F,GACzB1B,EAAOiB,MAAM,gCACbM,EAAcG,EAAK+F,UACnBzH,EAAOiB,MAAM,KAj+CLyG,CAAoBhG,GAExB,KAAK5B,EAAGU,WAAWmH,YAEf,YAg+CZ,SAA+BjG,GAG3B,GAFA1B,EAAOiB,MAAM,kCACbjB,EAAOiB,MAAM,KACe,IAAxBS,EAAKkG,QAAQzG,OAAc,CAE3BI,EADaG,EAAKkG,QAAS,SAGtBlG,EAAKkG,QAAQzG,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkG,QAASzG,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKkG,QAASvG,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAn/CL4G,CAAsBnG,GAE1B,KAAK5B,EAAGU,WAAWsH,UAEf,YAk/CZ,SAA6BpG,GACzB1B,EAAOiB,MAAM,gCACbuC,EAAyB9B,EAAKqG,aAC9B/H,EAAOiB,MAAM,KAt/CL+G,CAAoBtG,GAExB,KAAK5B,EAAGU,WAAWyH,UAEf,YAq/CZ,SAA6BvG,GAGzB,GAFA1B,EAAOiB,MAAM,gCACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAxgDLkH,CAAoBzG,GAExB,KAAK5B,EAAGU,WAAW4H,iBAEf,YAugDZ,SAAgC1G,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACiB,MAAvBM,EAAKqC,eACL/D,EAAOiB,MAAM,aAEbM,EAAcG,EAAKqC,gBAEvB/D,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KA5hDLoH,CAAuB3G,GAE3B,KAAK5B,EAAGU,WAAW8H,aAEf,YA2hDZ,SAAgC5G,GAC5B1B,EAAOiB,MAAM,mCACbuC,EAAyB9B,EAAKuC,MAC9BjE,EAAOiB,MAAM,KA/hDLsH,CAAuB7G,GAE3B,KAAK5B,EAAGU,WAAWgI,SAEf,YA8hDZ,SAA4B9G,GACxB1B,EAAOiB,MAAM,+BACbuC,EAAyB9B,EAAKuC,MAC9BjE,EAAOiB,MAAM,KAliDLwH,CAAmB/G,GAEvB,KAAK5B,EAAGU,WAAWkI,UAEf,YAiiDZ,SAA6BhH,GAGzB,GAFA1B,EAAOiB,MAAM,gCACbjB,EAAOiB,MAAM,KACa,IAAtBS,EAAKiH,MAAMxH,OAAc,CAEzBqC,EADa9B,EAAKiH,MAAO,SAGpBjH,EAAKiH,MAAMxH,OAAS,GACzBnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKiH,MAAOxH,OAAQE,IAAK,CACzC,IAAMwC,EAAOnC,EAAKiH,MAAOtH,GACrBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KApjDL2H,CAAoBlH,GAExB,KAAK5B,EAAGU,WAAWqI,iBAEf,YAmjDZ,SAAoCnH,GAGhC,GAFA1B,EAAOiB,MAAM,uCACbjB,EAAOiB,MAAM,KACa,IAAtBS,EAAKiH,MAAMxH,OAAc,CAEzBqC,EADa9B,EAAKiH,MAAO,SAGpBjH,EAAKiH,MAAMxH,OAAS,GACzBnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKiH,MAAOxH,OAAQE,IAAK,CACzC,IAAMwC,EAAOnC,EAAKiH,MAAOtH,GACrBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAtkDL6H,CAA2BpH,GAE/B,KAAK5B,EAAGU,WAAWuI,gBAEf,YAqkDZ,SAAmCrH,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVoC,EAAyB9B,EAAKsH,WAC9BhJ,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuH,aAC9BjJ,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKwH,UAC9BlJ,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKyH,cAElCnJ,EAAOiB,MAAM,KAllDLmI,CAA0B1H,GAE9B,KAAK5B,EAAGU,WAAW6I,UAEf,YAilDZ,SAA6B3H,GACzB1B,EAAOiB,MAAM,gCACbM,EAAcG,EAAK4H,eACnBtJ,EAAOiB,MAAM,KArlDLsI,CAAoB7H,GAExB,KAAK5B,EAAGU,WAAWgJ,WAEf,YAolDZ,SAA8B9H,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WASV,GARAoC,EAAyB9B,EAAK+H,UAC9BzJ,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKgI,UACL1J,EAAOiB,MAAM,aAEbM,EAAcG,EAAKgI,WAEvB1J,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAMS,EAAKiI,SAASlI,eAE/BzB,EAAOiB,MAAM,KAxnDL2I,CAAqBlI,GAEzB,KAAK5B,EAAGU,WAAWqJ,kBAEf,YAunDZ,SAAiCnI,GAC7B1B,EAAOiB,MAAM,oCACbuC,EAAyB9B,EAAKuC,MAC9BjE,EAAOiB,MAAM,KA3nDL6I,CAAwBpI,GAE5B,KAAK5B,EAAGU,WAAWuJ,SAEf,OA2nDR/J,EAAOiB,MAAM,oCACbjB,EAAOiB,MAAM,KA3nDT,KAAKnB,EAAGU,WAAWwJ,aAEf,YA4nDZ,SAAgCtI,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAKuI,WAC3DjK,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KAroDLiJ,CAAuBxI,GAE3B,KAAK5B,EAAGU,WAAW2J,kBAEf,YAooDZ,SAAqCzI,GACjC1B,EAAOiB,MAAM,wCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVoC,EAAyB9B,EAAK0I,YAC9BpK,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAK2I,cAElCrK,EAAOiB,MAAM,KA7oDLqJ,CAA4B5I,GAEhC,KAAK5B,EAAGU,WAAW+J,WAEf,YA4oDZ,SAA8B7I,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACgB,MAAtBM,EAAK8I,cACLxK,EAAOiB,MAAM,aAEbM,EAAcG,EAAK8I,eAEvBxK,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK4H,eACnBtJ,EAAOiB,MAAM,KAAKf,UACG,MAAjBwB,EAAK+I,SACLzK,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAK+I,UAElCzK,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsC,cACLhE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsC,eAEvBhE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,SAGtCjE,EAAOiB,MAAM,KA3qDLyJ,CAAqBhJ,GAEzB,KAAK5B,EAAGU,WAAWmK,YAEf,YA0qDZ,SAA+BjJ,GAC3B1B,EAAOiB,MAAM,kCACbM,EAAcG,EAAKsE,SACnBhG,EAAOiB,MAAM,KA9qDL2J,CAAsBlJ,GAE1B,KAAK5B,EAAGU,WAAWqK,oBAEf,YA6qDZ,SAAmCnJ,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVG,EAAcG,EAAKoJ,MACnB9K,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACqB,IAA9BS,EAAKqJ,cAAc5J,QAEnBI,EADaG,EAAKqJ,cAAe,IAG5BrJ,EAAKqJ,cAAc5J,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKqJ,cAAe5J,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKqJ,cAAe1J,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KArsDL+J,CAA0BtJ,GAE9B,KAAK5B,EAAGU,WAAWyK,qBAEf,YAosDZ,SAAoCvJ,GAGhC,GAFA1B,EAAOiB,MAAM,uCACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAvtDLiK,CAA2BxJ,GAE/B,KAAK5B,EAAGU,WAAW2K,oBAEf,YAstDZ,SAAmCzJ,GAG/B,GAFA1B,EAAOiB,MAAM,sCACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAzuDLmK,CAA0B1J,GAE9B,KAAK5B,EAAGU,WAAW6K,eAEf,YAwuDZ,SAA8B3J,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACiB,MAAvBM,EAAKqC,eACL/D,EAAOiB,MAAM,aAEbM,EAAcG,EAAKqC,gBAEvB/D,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAK4J,aACLtL,EAAOiB,MAAM,aAEbM,EAAcG,EAAK4J,cAEvBtL,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KAjwDLsK,CAAqB7J,GAEzB,KAAK5B,EAAGU,WAAWgL,uBAEf,YAgwDZ,SAAsC9J,GAClC1B,EAAOiB,MAAM,yCACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVpB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,QAEdI,EADaG,EAAKwG,SAAU,IAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,OAAQS,EAAa+J,YAAa,GAAOhK,eAEpDzB,EAAOiB,MAAM,KAxxDLyK,CAA6BhK,GAEjC,KAAK5B,EAAGU,WAAWmL,wBAEf,YAuxDZ,SAAuCjK,GACnC1B,EAAOiB,MAAM,0CACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVpB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkK,WAAWzK,QAEhBI,EADaG,EAAKkK,WAAY,IAGzBlK,EAAKkK,WAAWzK,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkK,WAAYzK,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkK,WAAYvK,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,OAAQS,EAAa+J,YAAa,GAAOhK,eAEpDzB,EAAOiB,MAAM,KA/yDL4K,CAA8BnK,GAElC,KAAK5B,EAAGU,WAAWsL,yBACf,GAAIhM,EAAGiM,sBAAsBrK,GAEzB,YAwzDhB,SAAmCA,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACW,MAAzBwB,EAAKsK,iBACLhM,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsK,kBAEvBhM,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,SAEvBb,EAAOiB,MAAM,KAv0DDgL,CAA0BvK,GAG9B,GAAI5B,EAAGoM,2BAA2BxK,GAE9B,YAyyDhB,SAAwCA,GACpC1B,EAAOiB,MAAM,2CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,SAEvBb,EAAOiB,MAAM,KAlzDDkL,CAA+BzK,GAGnC,MAAM,IAAI0K,MAAM,mBAAqB1K,EAAK2K,WAC9C,KAAKvM,EAAGU,WAAW8L,wBACf,GAAIxM,EAAGyM,qBAAqB7K,GAExB,YA00DhB,SAAkCA,GAC9B1B,EAAOiB,MAAM,qCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACW,MAAzBwB,EAAKsK,iBACLhM,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsK,kBAEvBhM,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK8K,uBAEvBxM,EAAOiB,MAAM,KAz1DDwL,CAAyB/K,GAG7B,GAAI5B,EAAG4M,0BAA0BhL,GAE7B,YA2zDhB,SAAuCA,GACnC1B,EAAOiB,MAAM,0CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK8K,uBAEvBxM,EAAOiB,MAAM,KAp0DD0L,CAA8BjL,GAGlC,MAAM,IAAI0K,MAAM,mBAAqB1K,EAAK2K,WAC9C,KAAKvM,EAAGU,WAAWoM,eACf,GAAI9M,EAAG+M,YAAYnL,GAEf,YAg4DhB,SAAyBA,GACrB1B,EAAOiB,MAAM,4BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WASV,GARAG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACW,MAAzBwB,EAAKsK,iBACLhM,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsK,kBAEvBhM,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoL,UAAU3L,QAEfI,EADaG,EAAKoL,UAAW,IAGxBpL,EAAKoL,UAAU3L,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoL,UAAW3L,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoL,UAAWzL,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KAn7DD8L,CAAgBrL,GAGpB,GAAI5B,EAAGkN,iBAAiBtL,GAEpB,YA60DhB,SAA8BA,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoL,UAAU3L,QAEfI,EADaG,EAAKoL,UAAW,IAGxBpL,EAAKoL,UAAU3L,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoL,UAAW3L,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoL,UAAWzL,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA13DDgM,CAAqBvL,GAGzB,MAAM,IAAI0K,MAAM,mBAAqB1K,EAAK2K,WAC9C,KAAKvM,EAAGU,WAAW0M,cAEf,YA46DZ,SAA6BxL,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoL,UACL9M,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoL,UAAU3L,OAEfI,EADaG,EAAKoL,UAAW,SAGxBpL,EAAKoL,UAAU3L,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoL,UAAW3L,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoL,UAAWzL,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,SAGrBjB,EAAOiB,MAAM,KA79DLkM,CAAoBzL,GAExB,KAAK5B,EAAGU,WAAW4M,yBAEf,YA49DZ,SAAwC1L,GACpC1B,EAAOiB,MAAM,2CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAK2L,KACnBrN,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK4L,aAEvBtN,EAAOiB,MAAM,KA1/DLsM,CAA+B7L,GAEnC,KAAK5B,EAAGU,WAAWgN,wBAEf,YAy/DZ,SAA6B9L,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVoC,EAAyB9B,EAAKuC,MAC9BjE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0B,eAEvBpD,EAAOiB,MAAM,KAlgELwM,CAAoB/L,GAExB,KAAK5B,EAAGU,WAAWkN,wBAEf,YAigEZ,SAAuChM,GACnC1B,EAAOiB,MAAM,0CACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KArgEL0M,CAA8BjM,GAElC,KAAK5B,EAAGU,WAAWoN,mBAEf,YAogEZ,SAAkClM,GAC9B1B,EAAOiB,MAAM,qCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAejB,GAbAjB,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsD,cACLhF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsD,eAEvBhF,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKb,KACLb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKb,MAEvBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKuD,SAEvBjF,EAAOiB,MAAM,KAxlEL4M,CAAyBnM,GAE7B,KAAK5B,EAAGU,WAAWsN,cAEf,YAulEZ,SAA6BpM,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKqM,wBACnB/N,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKuD,SAEvBjF,EAAOiB,MAAM,KAjqEL+M,CAAoBtM,GAExB,KAAK5B,EAAGU,WAAWyN,iBAEf,YAgqEZ,SAAgCvM,GAC5B1B,EAAOiB,MAAM,mCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KApqELiN,CAAuBxM,GAE3B,KAAK5B,EAAGU,WAAW2N,iBAEf,YAmqEZ,SAAgCzM,GAC5B1B,EAAOiB,MAAM,mCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAvqELmN,CAAuB1M,GAE3B,KAAK5B,EAAGU,WAAW6N,eAEf,YAsqEZ,SAA8B3M,GAC1B1B,EAAOiB,MAAM,iCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA1qELqN,CAAqB5M,GAEzB,KAAK5B,EAAGU,WAAW+N,gBAEf,YAyqEZ,SAA+B7M,GAC3B1B,EAAOiB,MAAM,kCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA7qELuN,CAAsB9M,GAE1B,KAAK5B,EAAGU,WAAWiO,sBAEf,YA4qEZ,SAAqC/M,GACjC1B,EAAOiB,MAAM,wCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAKuI,WAC3DjK,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKgN,YAEvB1O,EAAOiB,MAAM,KArrEL0N,CAA4BjN,GAEhC,KAAK5B,EAAGU,WAAWoO,uBAEf,YAorEZ,SAAsClN,GAClC1B,EAAOiB,MAAM,yCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKgN,SACnB1O,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAKuI,cAE/DjK,EAAOiB,MAAM,KA7rEL4N,CAA6BnN,GAEjC,KAAK5B,EAAGU,WAAWsO,iBAEf,YA4rEZ,SAAgCpN,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKsB,MACnBhD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKqN,eACnB/O,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKuB,UAEvBjD,EAAOiB,MAAM,KAvsEL+N,CAAuBtN,GAE3B,KAAK5B,EAAGU,WAAWyO,sBAEf,YAssEZ,SAAqCvN,GACjC1B,EAAOiB,MAAM,wCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKwN,WACnBlP,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKsC,eACnBhE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKyN,UACnBnP,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0N,YACnBpP,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK2N,cAEvBrP,EAAOiB,MAAM,KArtELqO,CAA4B5N,GAEhC,KAAK5B,EAAGU,WAAW+O,mBAEf,YAotEZ,SAAkC7N,GAC9B1B,EAAOiB,MAAM,qCACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVG,EAAcG,EAAKoJ,MACnB9K,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACqB,IAA9BS,EAAKqJ,cAAc5J,QAEnBI,EADaG,EAAKqJ,cAAe,IAG5BrJ,EAAKqJ,cAAc5J,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKqJ,cAAe5J,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKqJ,cAAe1J,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA5uELuO,CAAyB9N,GAE7B,KAAK5B,EAAGU,WAAWiP,aAEf,YA2uEZ,SAA4B/N,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAAKf,UACE,MAAhBwB,EAAKgO,QACL1P,EAAOiB,MAAM,aAEbjB,EAAO6B,MAAMH,EAAKgO,QAAQjO,eAGlCzB,EAAOiB,MAAM,KAxvEL0O,CAAmBjO,GAEvB,KAAK5B,EAAGU,WAAWoP,eAEf,YAuvEZ,SAA8BlO,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAAKf,UACE,MAAhBwB,EAAKgO,QACL1P,EAAOiB,MAAM,aAEbjB,EAAO6B,MAAMH,EAAKgO,QAAQjO,eAGlCzB,EAAOiB,MAAM,KApwEL4O,CAAqBnO,GAEzB,KAAK5B,EAAGU,WAAWsP,aAEf,YAmwEZ,SAA4BpO,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAAKf,UACE,MAAhBwB,EAAKgO,QACL1P,EAAOiB,MAAM,aAEbjB,EAAO6B,MAAMH,EAAKgO,QAAQjO,eAGlCzB,EAAOiB,MAAM,KAhxEL8O,CAAmBrO,GAEvB,KAAK5B,EAAGU,WAAWwP,8BAEf,YA+wEZ,SAA6CtO,GACzC1B,EAAOiB,MAAM,gDACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAAKf,UACE,MAAhBwB,EAAKgO,QACL1P,EAAOiB,MAAM,aAEbjB,EAAO6B,MAAMH,EAAKgO,QAAQjO,eAGlCzB,EAAOiB,MAAM,KA5xELgP,CAAoCvO,GAExC,KAAK5B,EAAGU,WAAW0P,gBAEf,YA2xEZ,SAA+BxO,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACgB,MAAtBM,EAAKsD,cACLhF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsD,eAEvBhF,EAAOiB,MAAM,KAAKf,UACK,MAAnBwB,EAAK0B,WACLpD,EAAOiB,MAAM,aAEbM,EAAcG,EAAK0B,eAG3BpD,EAAOiB,MAAM,KA5yELkP,CAAsBzO,GAE1B,KAAK5B,EAAGU,WAAW4P,cAEf,YA2yEZ,SAA6B1O,GACzB1B,EAAOiB,MAAM,gCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA/yELoP,CAAoB3O,GAExB,KAAK5B,EAAGU,WAAW8P,gBAEf,YA8yEZ,SAA+B5O,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KASjB,GAPAjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKb,KACLb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKb,MAEvBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACU,MAAxBwB,EAAK6O,gBACLvQ,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACuB,IAAhCS,EAAK6O,gBAAgBpP,OAErBI,EADaG,EAAK6O,gBAAiB,SAG9B7O,EAAK6O,gBAAgBpP,OAAS,GACnCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAK6O,gBAAiBpP,OAAQE,IAAK,CACnD,IAAMwC,EAAOnC,EAAK6O,gBAAiBlP,GAC/BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACe,IAAxBS,EAAKkG,QAAQzG,QAEbI,EADaG,EAAKkG,QAAS,IAGtBlG,EAAKkG,QAAQzG,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkG,QAASzG,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKkG,QAASvG,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA95ELuP,CAAsB9O,GAE1B,KAAK5B,EAAGU,WAAWiQ,kBAEf,OA85ERzQ,EAAOiB,MAAM,yCACbjB,EAAOiB,MAAM,KA95ET,KAAKnB,EAAGU,WAAWkQ,4BAEf,YA+5EZ,SAA2ChP,GACvC1B,EAAOiB,MAAM,8CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,SAGrBjB,EAAOiB,MAAM,KA37EL0P,CAAkCjP,GAEtC,KAAK5B,EAAGU,WAAWoQ,aAEf,YA07EZ,SAA4BlP,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KAn8EL4P,CAAmBnP,GAEvB,KAAK5B,EAAGU,WAAWsQ,kBACf,GAAIhR,EAAGiR,eAAerP,GAElB,YAu8EhB,SAA4BA,GACxB1B,EAAOiB,MAAM,+BACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA38ED+P,CAAmBtP,GAGvB,GAAI5B,EAAGmR,oBAAoBvP,GAEvB,YA67EhB,SAAiCA,GAC7B1B,EAAOiB,MAAM,oCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAj8EDiQ,CAAwBxP,GAG5B,MAAM,IAAI0K,MAAM,mBAAqB1K,EAAK2K,WAC9C,KAAKvM,EAAGU,WAAW2Q,aAEf,YAo8EZ,SAA4BzP,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAK0P,eAC3DpR,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,SAEvBb,EAAOiB,MAAM,KA78ELoQ,CAAmB3P,GAEvB,KAAK5B,EAAGU,WAAW8Q,aAEf,YA48EZ,SAA4B5P,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKsE,YAEvBhG,EAAOiB,MAAM,KAr9ELsQ,CAAmB7P,GAEvB,KAAK5B,EAAGU,WAAWgR,sBAEf,OAq9ERxR,EAAOiB,MAAM,6CACbjB,EAAOiB,MAAM,KAr9ET,KAAKnB,EAAGU,WAAWiR,MAEf,YAs9EZ,SAAqB/P,GACjB1B,EAAOiB,MAAM,wBACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVpB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKR,WAAWC,QAEhBI,EADaG,EAAKR,WAAY,IAGzBQ,EAAKR,WAAWC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKR,WAAYC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKR,WAAYG,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,OAAQS,EAAa+J,YAAa,GAAOhK,eAEpDzB,EAAOiB,MAAM,KA9+ELyQ,CAAYhQ,GAEhB,KAAK5B,EAAGU,WAAWmR,kBAEf,YA6+EZ,SAAiCjQ,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAsB,MAAlBM,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKkQ,oBAEvB5R,EAAOiB,MAAM,KAzgFL4Q,CAAwBnQ,GAE5B,KAAK5B,EAAGU,WAAWsR,eAEf,OAygFR9R,EAAOiB,MAAM,sCACbjB,EAAOiB,MAAM,KAzgFT,KAAKnB,EAAGU,WAAWuR,oBAEf,YA0gFZ,SAAmCrQ,GAC/B1B,EAAOiB,MAAM,sCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA9gFL+Q,CAA0BtQ,GAE9B,KAAK5B,EAAGU,WAAWyR,YAEf,YA6gFZ,SAA2BvQ,GACvB1B,EAAOiB,MAAM,8BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKwQ,eACnBlS,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKyQ,cACLnS,EAAOiB,MAAM,aAEbM,EAAcG,EAAKyQ,kBAG3BnS,EAAOiB,MAAM,KA5hFLmR,CAAkB1Q,GAEtB,KAAK5B,EAAGU,WAAW6R,YAEf,YA2hFZ,SAA2B3Q,GACvB1B,EAAOiB,MAAM,8BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKJ,WACnBtB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0B,eAEvBpD,EAAOiB,MAAM,KApiFLqR,CAAkB5Q,GAEtB,KAAK5B,EAAGU,WAAW+R,eAEf,YAmiFZ,SAA8B7Q,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KA5iFLuR,CAAqB9Q,GAEzB,KAAK5B,EAAGU,WAAWiS,aAEf,YA2iFZ,SAA4B/Q,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACc,MAApBM,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,aAEvBlE,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKwN,UACLlP,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwN,WAEvBlP,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKgR,YACL1S,EAAOiB,MAAM,aAEbM,EAAcG,EAAKgR,aAEvB1S,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KApkFL0R,CAAmBjR,GAEvB,KAAK5B,EAAGU,WAAWoS,eAEf,YAmkFZ,SAA8BlR,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKwC,aACnBlE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KA9kFL4R,CAAqBnR,GAEzB,KAAK5B,EAAGU,WAAWsS,eAEf,YA6kFZ,SAA8BpR,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACgB,MAAtBM,EAAKqR,cACL/S,EAAOiB,MAAM,aAEbM,EAAcG,EAAKqR,eAEvB/S,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKwC,aACnBlE,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KA9lFL+R,CAAqBtR,GAEzB,KAAK5B,EAAGU,WAAWyS,kBAEf,YA6lFZ,SAAiCvR,GAC7B1B,EAAOiB,MAAM,oCACK,MAAdS,EAAKwR,MACLlT,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwR,OAEvBlT,EAAOiB,MAAM,KArmFLkS,CAAwBzR,GAE5B,KAAK5B,EAAGU,WAAW4S,eAEf,YAomFZ,SAA8B1R,GAC1B1B,EAAOiB,MAAM,iCACK,MAAdS,EAAKwR,MACLlT,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwR,OAEvBlT,EAAOiB,MAAM,KA5mFLoS,CAAqB3R,GAEzB,KAAK5B,EAAGU,WAAW8S,gBAEf,YA2mFZ,SAA+B5R,GAC3B1B,EAAOiB,MAAM,kCACU,MAAnBS,EAAK0B,WACLpD,EAAOiB,MAAM,aAEbM,EAAcG,EAAK0B,YAEvBpD,EAAOiB,MAAM,KAnnFLsS,CAAsB7R,GAE1B,KAAK5B,EAAGU,WAAWgT,cAEf,YAknFZ,SAA6B9R,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KA3nFLwS,CAAoB/R,GAExB,KAAK5B,EAAGU,WAAWkT,gBAEf,YA0nFZ,SAA+BhS,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKiS,cAEvB3T,EAAOiB,MAAM,KAnoFL2S,CAAsBlS,GAE1B,KAAK5B,EAAGU,WAAWqT,iBAEf,YAkoFZ,SAAgCnS,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKwR,OACnBlT,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKJ,cAEvBtB,EAAOiB,MAAM,KA3oFL6S,CAAuBpS,GAE3B,KAAK5B,EAAGU,WAAWuT,eAEf,YA0oFZ,SAA8BrS,GAC1B1B,EAAOiB,MAAM,iCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA9oFL+S,CAAqBtS,GAEzB,KAAK5B,EAAGU,WAAWyT,aAEf,YA6oFZ,SAA4BvS,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKwS,UACnBlU,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKyS,YACLnU,EAAOiB,MAAM,aAEbM,EAAcG,EAAKyS,aAEvBnU,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAK0S,aACLpU,EAAOiB,MAAM,aAEbM,EAAcG,EAAK0S,iBAG3BpU,EAAOiB,MAAM,KAhqFLoT,CAAmB3S,GAEvB,KAAK5B,EAAGU,WAAW8T,kBAEf,OAgqFRtU,EAAOiB,MAAM,yCACbjB,EAAOiB,MAAM,KAhqFT,KAAKnB,EAAGU,WAAW+T,oBAEf,YAiqFZ,SAAmC7S,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACW,MAAzBwB,EAAK+C,iBACLzE,EAAOiB,MAAM,aAEbM,EAAcG,EAAK+C,kBAEvBzE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KA1rFLuT,CAA0B9S,GAE9B,KAAK5B,EAAGU,WAAWiU,wBAEf,YAyrFZ,SAAuC/S,GACnC1B,EAAOiB,MAAM,0CACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVpB,EAAOiB,MAAM,KACoB,IAA7BS,EAAKgT,aAAavT,QAElBI,EADaG,EAAKgT,aAAc,IAG3BhT,EAAKgT,aAAavT,OAAS,GAChCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKgT,aAAcvT,OAAQE,IAAK,CAChD,IAAMwC,EAAOnC,EAAKgT,aAAcrT,GAC5BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM0T,EAAkBjT,EAAKkT,OAAS,OAEjD5U,EAAOiB,MAAM,KAjtFL4T,CAA8BnT,GAElC,KAAK5B,EAAGU,WAAWsU,oBAEf,YAgtFZ,SAAmCpT,GAC/B1B,EAAOiB,MAAM,sCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAejB,GAbAjB,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKsD,cACLhF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKsD,eAEvBhF,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKb,KACLb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKb,MAEvBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKmD,WAAW1D,QAEhBI,EADaG,EAAKmD,WAAY,IAGzBnD,EAAKmD,WAAW1D,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmD,WAAY1D,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKmD,WAAYxD,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuC,KACLjE,EAAOiB,MAAM,aAEbuC,EAAyB9B,EAAKuC,MAElCjE,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,SAG3BjF,EAAOiB,MAAM,KA7zFL8T,CAA0BrT,GAE9B,KAAK5B,EAAGU,WAAWwU,iBAEf,YA4zFZ,SAAgCtT,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KASjB,GAPAjB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKb,KACLb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKb,MAEvBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACU,MAAxBwB,EAAK6O,gBACLvQ,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACuB,IAAhCS,EAAK6O,gBAAgBpP,OAErBI,EADaG,EAAK6O,gBAAiB,SAG9B7O,EAAK6O,gBAAgBpP,OAAS,GACnCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAK6O,gBAAiBpP,OAAQE,IAAK,CACnD,IAAMwC,EAAOnC,EAAK6O,gBAAiBlP,GAC/BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACe,IAAxBS,EAAKkG,QAAQzG,QAEbI,EADaG,EAAKkG,QAAS,IAGtBlG,EAAKkG,QAAQzG,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkG,QAASzG,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKkG,QAASvG,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA56FLgU,CAAuBvT,GAE3B,KAAK5B,EAAGU,WAAW0U,qBAEf,YA26FZ,SAAoCxT,GAChC1B,EAAOiB,MAAM,uCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAKjB,GAHAjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACU,MAAxBwB,EAAK6O,gBACLvQ,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACuB,IAAhCS,EAAK6O,gBAAgBpP,OAErBI,EADaG,EAAK6O,gBAAiB,SAG9B7O,EAAK6O,gBAAgBpP,OAAS,GACnCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAK6O,gBAAiBpP,OAAQE,IAAK,CACnD,IAAMwC,EAAOnC,EAAK6O,gBAAiBlP,GAC/BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACe,IAAxBS,EAAKkG,QAAQzG,QAEbI,EADaG,EAAKkG,QAAS,IAGtBlG,EAAKkG,QAAQzG,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkG,QAASzG,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKkG,QAASvG,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KAvhGLkU,CAA2BzT,GAE/B,KAAK5B,EAAGU,WAAW4U,qBAEf,YAshGZ,SAAoC1T,GAChC1B,EAAOiB,MAAM,uCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAKjB,GAHAjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKkD,eACL5E,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACsB,IAA/BS,EAAKkD,eAAezD,OAEpBI,EADaG,EAAKkD,eAAgB,SAG7BlD,EAAKkD,eAAezD,OAAS,GAClCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkD,eAAgBzD,OAAQE,IAAK,CAClD,IAAMwC,EAAOnC,EAAKkD,eAAgBvD,GAC9BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBsD,EAAyB9B,EAAKuC,SAElCjE,EAAOiB,MAAM,KA9lGLoU,CAA2B3T,GAE/B,KAAK5B,EAAGU,WAAW8U,gBAEf,YA6lGZ,SAA+B5T,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,MAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACe,IAAxBS,EAAKkG,QAAQzG,QAEbI,EADaG,EAAKkG,QAAS,IAGtBlG,EAAKkG,QAAQzG,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkG,QAASzG,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKkG,QAASvG,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA/pGLsU,CAAsB7T,GAE1B,KAAK5B,EAAGU,WAAWgV,kBAEf,YA8pGZ,SAAiC9T,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKuD,KACLjF,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuD,MAEvBjF,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM0T,EAAkBjT,EAAKkT,OAAS,OAEjD5U,EAAOiB,MAAM,KAvtGLwU,CAAwB/T,GAE5B,KAAK5B,EAAGU,WAAWkV,YAEf,YAstGZ,SAA2BhU,GAGvB,GAFA1B,EAAOiB,MAAM,8BACbjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKR,WAAWC,OAAc,CAE9BI,EADaG,EAAKR,WAAY,SAGzBQ,EAAKR,WAAWC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKR,WAAYC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKR,WAAYG,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAzuGL0U,CAAkBjU,GAEtB,KAAK5B,EAAGU,WAAWoV,UAEf,YAwuGZ,SAAyBlU,GAGrB,GAFA1B,EAAOiB,MAAM,4BACbjB,EAAOiB,MAAM,KACe,IAAxBS,EAAKmU,QAAQ1U,OAAc,CAE3BI,EADaG,EAAKmU,QAAS,SAGtBnU,EAAKmU,QAAQ1U,OAAS,GAC3BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKmU,QAAS1U,OAAQE,IAAK,CAC3C,IAAMwC,EAAOnC,EAAKmU,QAASxU,GACvBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KA3vGL6U,CAAgBpU,GAEpB,KAAK5B,EAAGU,WAAWuV,2BAEf,YA0vGZ,SAA0CrU,GACtC1B,EAAOiB,MAAM,6CACbM,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KA9vGL+U,CAAiCtU,GAErC,KAAK5B,EAAGU,WAAWyV,wBAEf,YA6vGZ,SAAuCvU,GACnC1B,EAAOiB,MAAM,0CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAMS,EAAKwU,WAAWzU,YAC7BzB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKyU,oBAEvBnW,EAAOiB,MAAM,KAlzGLmV,CAA8B1U,GAElC,KAAK5B,EAAGU,WAAW6V,kBAEf,YAizGZ,SAAiC3U,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAK4U,aACLtW,EAAOiB,MAAM,aAEbM,EAAcG,EAAK4U,cAEvBtW,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK6U,iBACnBvW,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAK8U,aACLxW,EAAOiB,MAAM,aAEbM,EAAcG,EAAK8U,iBAG3BxW,EAAOiB,MAAM,KA92GLwV,CAAwB/U,GAE5B,KAAK5B,EAAGU,WAAWkW,aAEf,YA62GZ,SAA4BhV,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAOiB,MAAMS,EAAKwU,WAAWzU,YAC7BzB,EAAOiB,MAAM,KAAKf,UACD,MAAbwB,EAAKb,KACLb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKb,MAEvBb,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKiV,cACL3W,EAAOiB,MAAM,aAEbM,EAAcG,EAAKiV,kBAG3B3W,EAAOiB,MAAM,KAh4GL2V,CAAmBlV,GAEvB,KAAK5B,EAAGU,WAAWqW,aAEf,YA+3GZ,SAA4BnV,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAOiB,MAAM,iBACbjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAK+J,UACLzL,EAAOiB,MAAM,aAEbjB,EAAOiB,MAAMS,EAAK+J,UAAUhK,eAGpCzB,EAAOiB,MAAM,KA54GL6V,CAAmBpV,GAEvB,KAAK5B,EAAGU,WAAWuW,YAEf,YA24GZ,SAA2BrV,GACvB1B,EAAOiB,MAAM,8BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKZ,UAEvBd,EAAOiB,MAAM,KAp5GL+V,CAAkBtV,GAEtB,KAAK5B,EAAGU,WAAWyW,gBAEf,YAm5GZ,SAA+BvV,GAC3B1B,EAAOiB,MAAM,kCACbM,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAv5GLiW,CAAsBxV,GAE1B,KAAK5B,EAAGU,WAAW2W,gBAEf,YAs5GZ,SAA+BzV,GAC3B1B,EAAOiB,MAAM,kCACbM,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KA15GLmW,CAAsB1V,GAE1B,KAAK5B,EAAGU,WAAW6W,aAEf,YAy5GZ,SAA4B3V,GAGxB,GAFA1B,EAAOiB,MAAM,+BACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KA56GLqW,CAAmB5V,GAEvB,KAAK5B,EAAGU,WAAW+W,gBAEf,YA26GZ,SAA+B7V,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACe,MAArBM,EAAK4J,aACLtL,EAAOiB,MAAM,aAEbM,EAAcG,EAAK4J,cAEvBtL,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,SAEvBb,EAAOiB,MAAM,KAx7GLuW,CAAsB9V,GAE1B,KAAK5B,EAAGU,WAAWiX,iBAEf,YAu7GZ,SAAgC/V,GAC5B1B,EAAOiB,MAAM,mCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UACS,MAAvBwB,EAAKgW,eACL1X,EAAOiB,MAAM,aAEbjB,EAAOiB,MAAMS,EAAKgW,eAAejW,YAErCzB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0B,eAEvBpD,EAAOiB,MAAM,KA9+GL0W,CAAuBjW,GAE3B,KAAK5B,EAAGU,WAAWoX,kBAEf,YA6+GZ,SAAiClW,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACV,GAAuB,MAAnBM,EAAKkC,WACL5D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkC,WAAWzC,OAEhBI,EADaG,EAAKkC,WAAY,SAGzBlC,EAAKkC,WAAWzC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkC,WAAYzC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkC,WAAYvC,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KAGjB,GADAjB,EAAOiB,MAAM,KAAKf,UACI,MAAlBwB,EAAKoC,UACL9D,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACiB,IAA1BS,EAAKoC,UAAU3C,OAAc,CAC7B,IAAM0C,EAAOnC,EAAKoC,UAAW,GAC7B9D,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,UAEhFD,EAAKoC,UAAU3C,OAAS,GAC7BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKoC,UAAW3C,OAAQE,IAAK,CAC7C,IAAMwC,EAAOnC,EAAKoC,UAAWzC,GACzBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBF,EAAOiB,MAAM,wCAA0Cb,EAAiByD,EAAKlC,MAAQ,SAIjG3B,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAMS,EAAKwU,WAAWzU,YAC7BzB,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAKmW,aACL7X,EAAOiB,MAAM,aAEbM,EAAcG,EAAKmW,cAEvB7X,EAAOiB,MAAM,KAAKf,UACU,MAAxBwB,EAAK6U,gBACLvW,EAAOiB,MAAM,aAEbM,EAAcG,EAAK6U,iBAEvBvW,EAAOiB,MAAM,KAAKf,UACO,MAArBwB,EAAK8U,aACLxW,EAAOiB,MAAM,aAEbM,EAAcG,EAAK8U,iBAG3BxW,EAAOiB,MAAM,KAhjHL6W,CAAwBpW,GAE5B,KAAK5B,EAAGU,WAAWuX,aAEf,YA+iHZ,SAA4BrW,GAGxB,GAFA1B,EAAOiB,MAAM,+BACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAlkHL+W,CAAmBtW,GAEvB,KAAK5B,EAAGU,WAAWyX,gBAEf,YAikHZ,SAA+BvW,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACe,MAArBM,EAAK4J,aACLtL,EAAOiB,MAAM,aAEbM,EAAcG,EAAK4J,cAEvBtL,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKb,SAEvBb,EAAOiB,MAAM,KA9kHLiX,CAAsBxW,GAE1B,KAAK5B,EAAGU,WAAW2X,wBAEf,YA6kHZ,SAAuCzW,GACnC1B,EAAOiB,MAAM,0CACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAjlHLmX,CAA8B1W,GAElC,KAAK5B,EAAGU,WAAW6X,WAEf,YAglHZ,SAA0B3W,GACtB1B,EAAOiB,MAAM,6BACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVG,EAAcG,EAAK4W,gBACnBtY,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACgB,IAAzBS,EAAK6W,SAASpX,QAEdI,EADaG,EAAK6W,SAAU,IAGvB7W,EAAK6W,SAASpX,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAK6W,SAAUpX,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAK6W,SAAUlX,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK8W,mBAEvBxY,EAAOiB,MAAM,KA1mHLwX,CAAiB/W,GAErB,KAAK5B,EAAGU,WAAWkY,sBAEf,YAymHZ,SAAqChX,GACjC1B,EAAOiB,MAAM,wCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAKiX,SACnB3Y,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKkX,eAEvB5Y,EAAOiB,MAAM,KAvoHL4X,CAA4BnX,GAEhC,KAAK5B,EAAGU,WAAWsY,kBAEf,YAsoHZ,SAAiCpX,GAC7B1B,EAAOiB,MAAM,oCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WAGV,GAFAG,EAAcG,EAAKiX,SACnB3Y,EAAOiB,MAAM,KAAKf,UACQ,MAAtBwB,EAAKwF,cACLlH,EAAOiB,MAAM,iBACZ,CAED,GADAjB,EAAOiB,MAAM,KACqB,IAA9BS,EAAKwF,cAAc/F,OAEnBqC,EADa9B,EAAKwF,cAAe,SAG5BxF,EAAKwF,cAAc/F,OAAS,GACjCnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwF,cAAe/F,OAAQE,IAAK,CACjD,IAAMwC,EAAOnC,EAAKwF,cAAe7F,GAC7BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBsD,EAAyBK,OAIrC7D,EAAOiB,MAAM,KAEjBjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKkX,eAEvB5Y,EAAOiB,MAAM,KApqHL8X,CAAwBrX,GAE5B,KAAK5B,EAAGU,WAAWwY,kBAEf,YAmqHZ,SAAiCtX,GAC7B1B,EAAOiB,MAAM,oCACbM,EAAcG,EAAKiX,SACnB3Y,EAAOiB,MAAM,KAvqHLgY,CAAwBvX,GAE5B,KAAK5B,EAAGU,WAAW0Y,YAEf,YAsqHZ,SAA2BxX,GACvB1B,EAAOiB,MAAM,8BACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVG,EAAcG,EAAKyX,iBACnBnZ,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACgB,IAAzBS,EAAK6W,SAASpX,QAEdI,EADaG,EAAK6W,SAAU,IAGvB7W,EAAK6W,SAASpX,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAK6W,SAAUpX,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAK6W,SAAUlX,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAK0X,oBAEvBpZ,EAAOiB,MAAM,KAhsHLoY,CAAkB3X,GAEtB,KAAK5B,EAAGU,WAAW8Y,QAEf,YA+rHZ,SAAuB5X,GACnB1B,EAAOiB,MAAM,0BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVpB,EAAO6B,MAAMH,EAAKI,KAAKL,YACvBzB,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAMS,EAAK6X,8BAA8B9X,eAEpDzB,EAAOiB,MAAM,KAxsHLuY,CAAc9X,GAElB,KAAK5B,EAAGU,WAAWiZ,mBAEf,OAwsHRzZ,EAAOiB,MAAM,0CACbjB,EAAOiB,MAAM,KAxsHT,KAAKnB,EAAGU,WAAWkZ,mBAEf,OA0sHR1Z,EAAOiB,MAAM,6CACbjB,EAAOiB,MAAM,KA1sHT,KAAKnB,EAAGU,WAAWmZ,aAEf,YA2sHZ,SAA4BjY,GACxB1B,EAAOiB,MAAM,+BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KAxtHL2Y,CAAmBlY,GAEvB,KAAK5B,EAAGU,WAAWqZ,cAEf,YAutHZ,SAA6BnY,GAGzB,GAFA1B,EAAOiB,MAAM,gCACbjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKkK,WAAWzK,OAAc,CAE9BI,EADaG,EAAKkK,WAAY,SAGzBlK,EAAKkK,WAAWzK,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKkK,WAAYzK,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKkK,WAAYvK,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KA1uHL6Y,CAAoBpY,GAExB,KAAK5B,EAAGU,WAAWuZ,mBAEf,YAyuHZ,SAAkCrY,GAC9B1B,EAAOiB,MAAM,qCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KA7uHL+Y,CAAyBtY,GAE7B,KAAK5B,EAAGU,WAAWyZ,cAEf,YA4uHZ,SAA6BvY,GACzB1B,EAAOiB,MAAM,gCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACiB,MAAvBM,EAAKqC,eACL/D,EAAOiB,MAAM,aAEbM,EAAcG,EAAKqC,gBAEvB/D,EAAOiB,MAAM,KAAKf,UACK,MAAnBwB,EAAK0B,WACLpD,EAAOiB,MAAM,aAEbM,EAAcG,EAAK0B,eAG3BpD,EAAOiB,MAAM,KA7vHLiZ,CAAoBxY,GAExB,KAAK5B,EAAGU,WAAW2Z,WAEf,YA4vHZ,SAA0BzY,GACtB1B,EAAOiB,MAAM,6BACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVG,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACkB,IAA3BS,EAAKR,WAAWC,QAEhBI,EADaG,EAAKR,WAAY,IAGzBQ,EAAKR,WAAWC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKR,WAAYC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKR,WAAYG,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KApxHLmZ,CAAiB1Y,GAErB,KAAK5B,EAAGU,WAAW6Z,cAEf,YAmxHZ,SAA6B3Y,GAGzB,GAFA1B,EAAOiB,MAAM,gCACbjB,EAAOiB,MAAM,KACkB,IAA3BS,EAAKR,WAAWC,OAAc,CAE9BI,EADaG,EAAKR,WAAY,SAGzBQ,EAAKR,WAAWC,OAAS,GAC9BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKR,WAAYC,OAAQE,IAAK,CAC9C,IAAMwC,EAAOnC,EAAKR,WAAYG,GAC1BA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KAtyHLqZ,CAAoB5Y,GAExB,KAAK5B,EAAGU,WAAW+Z,eAEf,YAqyHZ,SAA8B7Y,GAC1B1B,EAAOiB,MAAM,iCACbjB,EAAOE,UACPF,EAAOoB,QAAO,YACVpB,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAK8Y,QAC3Dxa,EAAOiB,MAAM,KAAKf,UAClBF,EAAOiB,MAAM,KACa,IAAtBS,EAAKiH,MAAMxH,QAEXI,EADaG,EAAKiH,MAAO,IAGpBjH,EAAKiH,MAAMxH,OAAS,GACzBnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKiH,MAAOxH,OAAQE,IAAK,CACzC,IAAMwC,EAAOnC,EAAKiH,MAAOtH,GACrBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,QAEjBjB,EAAOiB,MAAM,KA7zHLwZ,CAAqB/Y,GAEzB,KAAK5B,EAAGU,WAAWka,YAEf,YA4zHZ,SAA2BhZ,GACvB1B,EAAOiB,MAAM,8BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACsB,MAA5BM,EAAKiZ,oBACL3a,EAAOiB,MAAM,aAEbM,EAAcG,EAAKiZ,qBAEvB3a,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKkZ,UAEvB5a,EAAOiB,MAAM,KAz0HL4Z,CAAkBnZ,GAEtB,KAAK5B,EAAGU,WAAWsa,mBAEf,YAw0HZ,SAAkCpZ,GAC9B1B,EAAOiB,MAAM,qCACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UAClBqB,EAAcG,EAAKwC,gBAEvBlE,EAAOiB,MAAM,KAj1HL8Z,CAAyBrZ,GAE7B,KAAK5B,EAAGU,WAAWwa,4BAEf,YAg1HZ,SAA2CtZ,GACvC1B,EAAOiB,MAAM,8CACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACsB,MAApCwB,EAAKuZ,4BACLjb,EAAOiB,MAAM,aAEbM,EAAcG,EAAKuZ,gCAG3Bjb,EAAOiB,MAAM,KA71HLia,CAAkCxZ,GAEtC,KAAK5B,EAAGU,WAAW2a,iBAEf,YA41HZ,SAAgCzZ,GAC5B1B,EAAOiB,MAAM,mCACbM,EAAcG,EAAK0B,YACnBpD,EAAOiB,MAAM,KAh2HLma,CAAuB1Z,GAE3B,KAAK5B,EAAGU,WAAW6a,WAEf,YA+1HZ,SAA0B3Z,GACtB1B,EAAOiB,MAAM,6BACbjB,EAAOE,UACPF,EAAOoB,QAAO,WACVG,EAAcG,EAAKb,MACnBb,EAAOiB,MAAM,KAAKf,UACM,MAApBwB,EAAKwC,YACLlE,EAAOiB,MAAM,aAEbM,EAAcG,EAAKwC,gBAG3BlE,EAAOiB,MAAM,KA52HLqa,CAAiB5Z,GAErB,KAAK5B,EAAGU,WAAW+a,oBAEf,YA22HZ,SAAmC7Z,GAG/B,GAFA1B,EAAOiB,MAAM,sCACbjB,EAAOiB,MAAM,KACgB,IAAzBS,EAAKwG,SAAS/G,OAAc,CAE5BI,EADaG,EAAKwG,SAAU,SAGvBxG,EAAKwG,SAAS/G,OAAS,GAC5BnB,EAAOoB,QAAO,WACV,IAAK,IAAIC,EAAI,EAAGA,EAAIK,EAAKwG,SAAU/G,OAAQE,IAAK,CAC5C,IAAMwC,EAAOnC,EAAKwG,SAAU7G,GACxBA,EAAI,GACJrB,EAAOiB,MAAM,KAAKf,UACtBqB,EAAcsC,OAI1B7D,EAAOiB,MAAM,KACbjB,EAAOiB,MAAM,KA93HLua,CAA0B9Z,GAE9B,QACI,GAAIA,EAAKC,MAAQ7B,EAAGU,WAAWib,YAAc/Z,EAAKC,MAAQ7B,EAAGU,WAAWkb,UAEpE,YADA1b,EAAOiB,MAAM,sCAAsCA,MAAMb,EAAiBsB,EAAKC,OAAOV,MAAM,KAGhGjB,EAAOiB,MAAM,4BAA4BA,MAAMb,EAAiBsB,EAAKC,OAAOV,MAAM,QAI9F,SAASuC,EAAyB9B,GAC1BA,EAAKC,MAAQ7B,EAAGU,WAAWmb,cAAgBja,EAAKC,MAAQ7B,EAAGU,WAAWob,YACtE5b,EAAOiB,MAAM,gDAAgDA,MAAMb,EAAiBsB,EAAKC,OAAOV,MAAM,KAGtGM,EAAcG,GAm7BtB,SAASqF,EAAsBrF,GAC3B1B,EAAOiB,MAAM,kCACbjB,EAAOiB,MAAM,kBAAkBA,MAAMb,EAAiBsB,EAAKC,OAC3D3B,EAAOiB,MAAM,KAq8FjB,SAAS0T,EAAkB7T,GAEvB,OAGJ,SAA+B+a,EAAcC,EAAkBhb,EAAeib,EAAqBC,GAC/FA,EAAaA,GAAcC,EAAcJ,EAAS/a,GAClD,IAFsH,EAEhH8G,EAAoB,GAF4F,cAG9FoU,GAH8F,IAGtH,gCAAWE,EAAX,QACItU,EAAQuU,KAAKL,EAAW,IAAMD,EAAQK,KAJ4E,8BAK/F,IAAnBtU,EAAQzG,QACRyG,EAAQuU,KAAKL,EAAW,IAAMC,GAClC,OAAOnU,EAAQwU,KAAK,OAVbC,CAAsBvc,EAAGwc,UAAW,eAAgBxb,GAAS,EAAG,OAAQmb,EAAcnc,EAAGwc,UAAWxb,GAAOL,QAAO,SAAA8b,GAAC,OAAIA,IAAMzc,EAAGwc,UAAUE,gBAarJ,SAASP,EAAcJ,EAAc/a,GACjC,IAAM8G,EAAoB,GAC1B,IAAK,IAAM6U,KAAQZ,EACc,kBAAlBA,EAAQY,IAEa,KAA3BZ,EAAQY,GAAQ3b,IACjB8G,EAAQuU,KAAKN,EAAQY,IAE7B,OAAO7U","file":"static/js/48.058b9cea.chunk.js","sourcesContent":["import CodeBlockWriter from \"code-block-writer\";\n\nexport function generateFactoryCode(ts: typeof import(\"typescript-next\"), initialNode: import(\"typescript-next\").Node) {\n    const writer = new CodeBlockWriter({ newLine: \"\\n\", indentNumberOfSpaces: 2 });\n    const syntaxKindToName = createSyntaxKindToNameMap();\n\n    if (ts.isSourceFile(initialNode)) {\n        writer.write(\"[\");\n        if (initialNode.statements.length > 0) {\n            writer.indent(() => {\n                for (let i = 0; i < initialNode.statements.length; i++) {\n                    const statement = initialNode.statements[i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(statement);\n                }\n            }).newLine();\n        }\n        writer.write(\"];\");\n    }\n    else {\n        writeNodeText(initialNode);\n    }\n    writer.newLineIfLastNot();\n\n    return writer.toString();\n\n    function writeNodeText(node: import(\"typescript-next\").Node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.NumericLiteral:\n                createNumericLiteral(node as import(\"typescript-next\").NumericLiteral);\n                return;\n            case ts.SyntaxKind.BigIntLiteral:\n                createBigIntLiteral(node as import(\"typescript-next\").BigIntLiteral);\n                return;\n            case ts.SyntaxKind.StringLiteral:\n                createStringLiteral(node as import(\"typescript-next\").StringLiteral);\n                return;\n            case ts.SyntaxKind.RegularExpressionLiteral:\n                createRegularExpressionLiteral(node as import(\"typescript-next\").RegularExpressionLiteral);\n                return;\n            case ts.SyntaxKind.Identifier:\n                createIdentifier(node as import(\"typescript-next\").Identifier);\n                return;\n            case ts.SyntaxKind.PrivateIdentifier:\n                createPrivateIdentifier(node as import(\"typescript-next\").PrivateIdentifier);\n                return;\n            case ts.SyntaxKind.SuperKeyword:\n                createSuper(node as import(\"typescript-next\").SuperExpression);\n                return;\n            case ts.SyntaxKind.ThisKeyword:\n                createThis(node as import(\"typescript-next\").ThisExpression);\n                return;\n            case ts.SyntaxKind.NullKeyword:\n                createNull(node as import(\"typescript-next\").NullLiteral);\n                return;\n            case ts.SyntaxKind.TrueKeyword:\n                createTrue(node as import(\"typescript-next\").TrueLiteral);\n                return;\n            case ts.SyntaxKind.FalseKeyword:\n                createFalse(node as import(\"typescript-next\").FalseLiteral);\n                return;\n            case ts.SyntaxKind.QualifiedName:\n                createQualifiedName(node as import(\"typescript-next\").QualifiedName);\n                return;\n            case ts.SyntaxKind.ComputedPropertyName:\n                createComputedPropertyName(node as import(\"typescript-next\").ComputedPropertyName);\n                return;\n            case ts.SyntaxKind.TypeParameter:\n                createTypeParameterDeclaration(node as import(\"typescript-next\").TypeParameterDeclaration);\n                return;\n            case ts.SyntaxKind.Parameter:\n                createParameterDeclaration(node as import(\"typescript-next\").ParameterDeclaration);\n                return;\n            case ts.SyntaxKind.Decorator:\n                createDecorator(node as import(\"typescript-next\").Decorator);\n                return;\n            case ts.SyntaxKind.PropertySignature:\n                createPropertySignature(node as import(\"typescript-next\").PropertySignature);\n                return;\n            case ts.SyntaxKind.PropertyDeclaration:\n                createPropertyDeclaration(node as import(\"typescript-next\").PropertyDeclaration);\n                return;\n            case ts.SyntaxKind.MethodSignature:\n                createMethodSignature(node as import(\"typescript-next\").MethodSignature);\n                return;\n            case ts.SyntaxKind.MethodDeclaration:\n                createMethodDeclaration(node as import(\"typescript-next\").MethodDeclaration);\n                return;\n            case ts.SyntaxKind.Constructor:\n                createConstructorDeclaration(node as import(\"typescript-next\").ConstructorDeclaration);\n                return;\n            case ts.SyntaxKind.GetAccessor:\n                createGetAccessorDeclaration(node as import(\"typescript-next\").GetAccessorDeclaration);\n                return;\n            case ts.SyntaxKind.SetAccessor:\n                createSetAccessorDeclaration(node as import(\"typescript-next\").SetAccessorDeclaration);\n                return;\n            case ts.SyntaxKind.CallSignature:\n                createCallSignature(node as import(\"typescript-next\").CallSignatureDeclaration);\n                return;\n            case ts.SyntaxKind.ConstructSignature:\n                createConstructSignature(node as import(\"typescript-next\").ConstructSignatureDeclaration);\n                return;\n            case ts.SyntaxKind.IndexSignature:\n                createIndexSignature(node as import(\"typescript-next\").IndexSignatureDeclaration);\n                return;\n            case ts.SyntaxKind.TemplateLiteralTypeSpan:\n                createTemplateLiteralTypeSpan(node as import(\"typescript-next\").TemplateLiteralTypeSpan);\n                return;\n            case ts.SyntaxKind.ClassStaticBlockDeclaration:\n                createClassStaticBlockDeclaration(node as import(\"typescript-next\").ClassStaticBlockDeclaration);\n                return;\n            case ts.SyntaxKind.AnyKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.BooleanKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.IntrinsicKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.NeverKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.NumberKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.ObjectKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.StringKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.SymbolKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.UndefinedKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.UnknownKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.BigIntKeyword:\n                createKeywordTypeNode(node as import(\"typescript-next\").KeywordTypeNode);\n                return;\n            case ts.SyntaxKind.TypeReference:\n                createTypeReferenceNode(node as import(\"typescript-next\").TypeReferenceNode);\n                return;\n            case ts.SyntaxKind.FunctionType:\n                createFunctionTypeNode(node as import(\"typescript-next\").FunctionTypeNode);\n                return;\n            case ts.SyntaxKind.ConstructorType:\n                createConstructorTypeNode(node as import(\"typescript-next\").ConstructorTypeNode);\n                return;\n            case ts.SyntaxKind.TypeQuery:\n                createTypeQueryNode(node as import(\"typescript-next\").TypeQueryNode);\n                return;\n            case ts.SyntaxKind.TypeLiteral:\n                createTypeLiteralNode(node as import(\"typescript-next\").TypeLiteralNode);\n                return;\n            case ts.SyntaxKind.ArrayType:\n                createArrayTypeNode(node as import(\"typescript-next\").ArrayTypeNode);\n                return;\n            case ts.SyntaxKind.TupleType:\n                createTupleTypeNode(node as import(\"typescript-next\").TupleTypeNode);\n                return;\n            case ts.SyntaxKind.NamedTupleMember:\n                createNamedTupleMember(node as import(\"typescript-next\").NamedTupleMember);\n                return;\n            case ts.SyntaxKind.OptionalType:\n                createOptionalTypeNode(node as import(\"typescript-next\").OptionalTypeNode);\n                return;\n            case ts.SyntaxKind.RestType:\n                createRestTypeNode(node as import(\"typescript-next\").RestTypeNode);\n                return;\n            case ts.SyntaxKind.UnionType:\n                createUnionTypeNode(node as import(\"typescript-next\").UnionTypeNode);\n                return;\n            case ts.SyntaxKind.IntersectionType:\n                createIntersectionTypeNode(node as import(\"typescript-next\").IntersectionTypeNode);\n                return;\n            case ts.SyntaxKind.ConditionalType:\n                createConditionalTypeNode(node as import(\"typescript-next\").ConditionalTypeNode);\n                return;\n            case ts.SyntaxKind.InferType:\n                createInferTypeNode(node as import(\"typescript-next\").InferTypeNode);\n                return;\n            case ts.SyntaxKind.ImportType:\n                createImportTypeNode(node as import(\"typescript-next\").ImportTypeNode);\n                return;\n            case ts.SyntaxKind.ParenthesizedType:\n                createParenthesizedType(node as import(\"typescript-next\").ParenthesizedTypeNode);\n                return;\n            case ts.SyntaxKind.ThisType:\n                createThisTypeNode(node as import(\"typescript-next\").ThisTypeNode);\n                return;\n            case ts.SyntaxKind.TypeOperator:\n                createTypeOperatorNode(node as import(\"typescript-next\").TypeOperatorNode);\n                return;\n            case ts.SyntaxKind.IndexedAccessType:\n                createIndexedAccessTypeNode(node as import(\"typescript-next\").IndexedAccessTypeNode);\n                return;\n            case ts.SyntaxKind.MappedType:\n                createMappedTypeNode(node as import(\"typescript-next\").MappedTypeNode);\n                return;\n            case ts.SyntaxKind.LiteralType:\n                createLiteralTypeNode(node as import(\"typescript-next\").LiteralTypeNode);\n                return;\n            case ts.SyntaxKind.TemplateLiteralType:\n                createTemplateLiteralType(node as import(\"typescript-next\").TemplateLiteralTypeNode);\n                return;\n            case ts.SyntaxKind.ObjectBindingPattern:\n                createObjectBindingPattern(node as import(\"typescript-next\").ObjectBindingPattern);\n                return;\n            case ts.SyntaxKind.ArrayBindingPattern:\n                createArrayBindingPattern(node as import(\"typescript-next\").ArrayBindingPattern);\n                return;\n            case ts.SyntaxKind.BindingElement:\n                createBindingElement(node as import(\"typescript-next\").BindingElement);\n                return;\n            case ts.SyntaxKind.ArrayLiteralExpression:\n                createArrayLiteralExpression(node as import(\"typescript-next\").ArrayLiteralExpression);\n                return;\n            case ts.SyntaxKind.ObjectLiteralExpression:\n                createObjectLiteralExpression(node as import(\"typescript-next\").ObjectLiteralExpression);\n                return;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                if (ts.isPropertyAccessChain(node)) {\n                    createPropertyAccessChain(node as import(\"typescript-next\").PropertyAccessChain);\n                    return;\n                }\n                if (ts.isPropertyAccessExpression(node)) {\n                    createPropertyAccessExpression(node as import(\"typescript-next\").PropertyAccessExpression);\n                    return;\n                }\n                throw new Error(\"Unhandled node: \" + node.getText());\n            case ts.SyntaxKind.ElementAccessExpression:\n                if (ts.isElementAccessChain(node)) {\n                    createElementAccessChain(node as import(\"typescript-next\").ElementAccessChain);\n                    return;\n                }\n                if (ts.isElementAccessExpression(node)) {\n                    createElementAccessExpression(node as import(\"typescript-next\").ElementAccessExpression);\n                    return;\n                }\n                throw new Error(\"Unhandled node: \" + node.getText());\n            case ts.SyntaxKind.CallExpression:\n                if (ts.isCallChain(node)) {\n                    createCallChain(node as import(\"typescript-next\").CallChain);\n                    return;\n                }\n                if (ts.isCallExpression(node)) {\n                    createCallExpression(node as import(\"typescript-next\").CallExpression);\n                    return;\n                }\n                throw new Error(\"Unhandled node: \" + node.getText());\n            case ts.SyntaxKind.NewExpression:\n                createNewExpression(node as import(\"typescript-next\").NewExpression);\n                return;\n            case ts.SyntaxKind.TaggedTemplateExpression:\n                createTaggedTemplateExpression(node as import(\"typescript-next\").TaggedTemplateExpression);\n                return;\n            case ts.SyntaxKind.TypeAssertionExpression:\n                createTypeAssertion(node as import(\"typescript-next\").TypeAssertion);\n                return;\n            case ts.SyntaxKind.ParenthesizedExpression:\n                createParenthesizedExpression(node as import(\"typescript-next\").ParenthesizedExpression);\n                return;\n            case ts.SyntaxKind.FunctionExpression:\n                createFunctionExpression(node as import(\"typescript-next\").FunctionExpression);\n                return;\n            case ts.SyntaxKind.ArrowFunction:\n                createArrowFunction(node as import(\"typescript-next\").ArrowFunction);\n                return;\n            case ts.SyntaxKind.DeleteExpression:\n                createDeleteExpression(node as import(\"typescript-next\").DeleteExpression);\n                return;\n            case ts.SyntaxKind.TypeOfExpression:\n                createTypeOfExpression(node as import(\"typescript-next\").TypeOfExpression);\n                return;\n            case ts.SyntaxKind.VoidExpression:\n                createVoidExpression(node as import(\"typescript-next\").VoidExpression);\n                return;\n            case ts.SyntaxKind.AwaitExpression:\n                createAwaitExpression(node as import(\"typescript-next\").AwaitExpression);\n                return;\n            case ts.SyntaxKind.PrefixUnaryExpression:\n                createPrefixUnaryExpression(node as import(\"typescript-next\").PrefixUnaryExpression);\n                return;\n            case ts.SyntaxKind.PostfixUnaryExpression:\n                createPostfixUnaryExpression(node as import(\"typescript-next\").PostfixUnaryExpression);\n                return;\n            case ts.SyntaxKind.BinaryExpression:\n                createBinaryExpression(node as import(\"typescript-next\").BinaryExpression);\n                return;\n            case ts.SyntaxKind.ConditionalExpression:\n                createConditionalExpression(node as import(\"typescript-next\").ConditionalExpression);\n                return;\n            case ts.SyntaxKind.TemplateExpression:\n                createTemplateExpression(node as import(\"typescript-next\").TemplateExpression);\n                return;\n            case ts.SyntaxKind.TemplateHead:\n                createTemplateHead(node as import(\"typescript-next\").TemplateHead);\n                return;\n            case ts.SyntaxKind.TemplateMiddle:\n                createTemplateMiddle(node as import(\"typescript-next\").TemplateMiddle);\n                return;\n            case ts.SyntaxKind.TemplateTail:\n                createTemplateTail(node as import(\"typescript-next\").TemplateTail);\n                return;\n            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n                createNoSubstitutionTemplateLiteral(node as import(\"typescript-next\").NoSubstitutionTemplateLiteral);\n                return;\n            case ts.SyntaxKind.YieldExpression:\n                createYieldExpression(node as import(\"typescript-next\").YieldExpression);\n                return;\n            case ts.SyntaxKind.SpreadElement:\n                createSpreadElement(node as import(\"typescript-next\").SpreadElement);\n                return;\n            case ts.SyntaxKind.ClassExpression:\n                createClassExpression(node as import(\"typescript-next\").ClassExpression);\n                return;\n            case ts.SyntaxKind.OmittedExpression:\n                createOmittedExpression(node as import(\"typescript-next\").OmittedExpression);\n                return;\n            case ts.SyntaxKind.ExpressionWithTypeArguments:\n                createExpressionWithTypeArguments(node as import(\"typescript-next\").ExpressionWithTypeArguments);\n                return;\n            case ts.SyntaxKind.AsExpression:\n                createAsExpression(node as import(\"typescript-next\").AsExpression);\n                return;\n            case ts.SyntaxKind.NonNullExpression:\n                if (ts.isNonNullChain(node)) {\n                    createNonNullChain(node as import(\"typescript-next\").NonNullChain);\n                    return;\n                }\n                if (ts.isNonNullExpression(node)) {\n                    createNonNullExpression(node as import(\"typescript-next\").NonNullExpression);\n                    return;\n                }\n                throw new Error(\"Unhandled node: \" + node.getText());\n            case ts.SyntaxKind.MetaProperty:\n                createMetaProperty(node as import(\"typescript-next\").MetaProperty);\n                return;\n            case ts.SyntaxKind.TemplateSpan:\n                createTemplateSpan(node as import(\"typescript-next\").TemplateSpan);\n                return;\n            case ts.SyntaxKind.SemicolonClassElement:\n                createSemicolonClassElement(node as import(\"typescript-next\").SemicolonClassElement);\n                return;\n            case ts.SyntaxKind.Block:\n                createBlock(node as import(\"typescript-next\").Block);\n                return;\n            case ts.SyntaxKind.VariableStatement:\n                createVariableStatement(node as import(\"typescript-next\").VariableStatement);\n                return;\n            case ts.SyntaxKind.EmptyStatement:\n                createEmptyStatement(node as import(\"typescript-next\").EmptyStatement);\n                return;\n            case ts.SyntaxKind.ExpressionStatement:\n                createExpressionStatement(node as import(\"typescript-next\").ExpressionStatement);\n                return;\n            case ts.SyntaxKind.IfStatement:\n                createIfStatement(node as import(\"typescript-next\").IfStatement);\n                return;\n            case ts.SyntaxKind.DoStatement:\n                createDoStatement(node as import(\"typescript-next\").DoStatement);\n                return;\n            case ts.SyntaxKind.WhileStatement:\n                createWhileStatement(node as import(\"typescript-next\").WhileStatement);\n                return;\n            case ts.SyntaxKind.ForStatement:\n                createForStatement(node as import(\"typescript-next\").ForStatement);\n                return;\n            case ts.SyntaxKind.ForInStatement:\n                createForInStatement(node as import(\"typescript-next\").ForInStatement);\n                return;\n            case ts.SyntaxKind.ForOfStatement:\n                createForOfStatement(node as import(\"typescript-next\").ForOfStatement);\n                return;\n            case ts.SyntaxKind.ContinueStatement:\n                createContinueStatement(node as import(\"typescript-next\").ContinueStatement);\n                return;\n            case ts.SyntaxKind.BreakStatement:\n                createBreakStatement(node as import(\"typescript-next\").BreakStatement);\n                return;\n            case ts.SyntaxKind.ReturnStatement:\n                createReturnStatement(node as import(\"typescript-next\").ReturnStatement);\n                return;\n            case ts.SyntaxKind.WithStatement:\n                createWithStatement(node as import(\"typescript-next\").WithStatement);\n                return;\n            case ts.SyntaxKind.SwitchStatement:\n                createSwitchStatement(node as import(\"typescript-next\").SwitchStatement);\n                return;\n            case ts.SyntaxKind.LabeledStatement:\n                createLabeledStatement(node as import(\"typescript-next\").LabeledStatement);\n                return;\n            case ts.SyntaxKind.ThrowStatement:\n                createThrowStatement(node as import(\"typescript-next\").ThrowStatement);\n                return;\n            case ts.SyntaxKind.TryStatement:\n                createTryStatement(node as import(\"typescript-next\").TryStatement);\n                return;\n            case ts.SyntaxKind.DebuggerStatement:\n                createDebuggerStatement(node as import(\"typescript-next\").DebuggerStatement);\n                return;\n            case ts.SyntaxKind.VariableDeclaration:\n                createVariableDeclaration(node as import(\"typescript-next\").VariableDeclaration);\n                return;\n            case ts.SyntaxKind.VariableDeclarationList:\n                createVariableDeclarationList(node as import(\"typescript-next\").VariableDeclarationList);\n                return;\n            case ts.SyntaxKind.FunctionDeclaration:\n                createFunctionDeclaration(node as import(\"typescript-next\").FunctionDeclaration);\n                return;\n            case ts.SyntaxKind.ClassDeclaration:\n                createClassDeclaration(node as import(\"typescript-next\").ClassDeclaration);\n                return;\n            case ts.SyntaxKind.InterfaceDeclaration:\n                createInterfaceDeclaration(node as import(\"typescript-next\").InterfaceDeclaration);\n                return;\n            case ts.SyntaxKind.TypeAliasDeclaration:\n                createTypeAliasDeclaration(node as import(\"typescript-next\").TypeAliasDeclaration);\n                return;\n            case ts.SyntaxKind.EnumDeclaration:\n                createEnumDeclaration(node as import(\"typescript-next\").EnumDeclaration);\n                return;\n            case ts.SyntaxKind.ModuleDeclaration:\n                createModuleDeclaration(node as import(\"typescript-next\").ModuleDeclaration);\n                return;\n            case ts.SyntaxKind.ModuleBlock:\n                createModuleBlock(node as import(\"typescript-next\").ModuleBlock);\n                return;\n            case ts.SyntaxKind.CaseBlock:\n                createCaseBlock(node as import(\"typescript-next\").CaseBlock);\n                return;\n            case ts.SyntaxKind.NamespaceExportDeclaration:\n                createNamespaceExportDeclaration(node as import(\"typescript-next\").NamespaceExportDeclaration);\n                return;\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                createImportEqualsDeclaration(node as import(\"typescript-next\").ImportEqualsDeclaration);\n                return;\n            case ts.SyntaxKind.ImportDeclaration:\n                createImportDeclaration(node as import(\"typescript-next\").ImportDeclaration);\n                return;\n            case ts.SyntaxKind.ImportClause:\n                createImportClause(node as import(\"typescript-next\").ImportClause);\n                return;\n            case ts.SyntaxKind.AssertClause:\n                createAssertClause(node as import(\"typescript-next\").AssertClause);\n                return;\n            case ts.SyntaxKind.AssertEntry:\n                createAssertEntry(node as import(\"typescript-next\").AssertEntry);\n                return;\n            case ts.SyntaxKind.NamespaceImport:\n                createNamespaceImport(node as import(\"typescript-next\").NamespaceImport);\n                return;\n            case ts.SyntaxKind.NamespaceExport:\n                createNamespaceExport(node as import(\"typescript-next\").NamespaceExport);\n                return;\n            case ts.SyntaxKind.NamedImports:\n                createNamedImports(node as import(\"typescript-next\").NamedImports);\n                return;\n            case ts.SyntaxKind.ImportSpecifier:\n                createImportSpecifier(node as import(\"typescript-next\").ImportSpecifier);\n                return;\n            case ts.SyntaxKind.ExportAssignment:\n                createExportAssignment(node as import(\"typescript-next\").ExportAssignment);\n                return;\n            case ts.SyntaxKind.ExportDeclaration:\n                createExportDeclaration(node as import(\"typescript-next\").ExportDeclaration);\n                return;\n            case ts.SyntaxKind.NamedExports:\n                createNamedExports(node as import(\"typescript-next\").NamedExports);\n                return;\n            case ts.SyntaxKind.ExportSpecifier:\n                createExportSpecifier(node as import(\"typescript-next\").ExportSpecifier);\n                return;\n            case ts.SyntaxKind.ExternalModuleReference:\n                createExternalModuleReference(node as import(\"typescript-next\").ExternalModuleReference);\n                return;\n            case ts.SyntaxKind.JsxElement:\n                createJsxElement(node as import(\"typescript-next\").JsxElement);\n                return;\n            case ts.SyntaxKind.JsxSelfClosingElement:\n                createJsxSelfClosingElement(node as import(\"typescript-next\").JsxSelfClosingElement);\n                return;\n            case ts.SyntaxKind.JsxOpeningElement:\n                createJsxOpeningElement(node as import(\"typescript-next\").JsxOpeningElement);\n                return;\n            case ts.SyntaxKind.JsxClosingElement:\n                createJsxClosingElement(node as import(\"typescript-next\").JsxClosingElement);\n                return;\n            case ts.SyntaxKind.JsxFragment:\n                createJsxFragment(node as import(\"typescript-next\").JsxFragment);\n                return;\n            case ts.SyntaxKind.JsxText:\n                createJsxText(node as import(\"typescript-next\").JsxText);\n                return;\n            case ts.SyntaxKind.JsxOpeningFragment:\n                createJsxOpeningFragment(node as import(\"typescript-next\").JsxOpeningFragment);\n                return;\n            case ts.SyntaxKind.JsxClosingFragment:\n                createJsxJsxClosingFragment(node as import(\"typescript-next\").JsxClosingFragment);\n                return;\n            case ts.SyntaxKind.JsxAttribute:\n                createJsxAttribute(node as import(\"typescript-next\").JsxAttribute);\n                return;\n            case ts.SyntaxKind.JsxAttributes:\n                createJsxAttributes(node as import(\"typescript-next\").JsxAttributes);\n                return;\n            case ts.SyntaxKind.JsxSpreadAttribute:\n                createJsxSpreadAttribute(node as import(\"typescript-next\").JsxSpreadAttribute);\n                return;\n            case ts.SyntaxKind.JsxExpression:\n                createJsxExpression(node as import(\"typescript-next\").JsxExpression);\n                return;\n            case ts.SyntaxKind.CaseClause:\n                createCaseClause(node as import(\"typescript-next\").CaseClause);\n                return;\n            case ts.SyntaxKind.DefaultClause:\n                createDefaultClause(node as import(\"typescript-next\").DefaultClause);\n                return;\n            case ts.SyntaxKind.HeritageClause:\n                createHeritageClause(node as import(\"typescript-next\").HeritageClause);\n                return;\n            case ts.SyntaxKind.CatchClause:\n                createCatchClause(node as import(\"typescript-next\").CatchClause);\n                return;\n            case ts.SyntaxKind.PropertyAssignment:\n                createPropertyAssignment(node as import(\"typescript-next\").PropertyAssignment);\n                return;\n            case ts.SyntaxKind.ShorthandPropertyAssignment:\n                createShorthandPropertyAssignment(node as import(\"typescript-next\").ShorthandPropertyAssignment);\n                return;\n            case ts.SyntaxKind.SpreadAssignment:\n                createSpreadAssignment(node as import(\"typescript-next\").SpreadAssignment);\n                return;\n            case ts.SyntaxKind.EnumMember:\n                createEnumMember(node as import(\"typescript-next\").EnumMember);\n                return;\n            case ts.SyntaxKind.CommaListExpression:\n                createCommaListExpression(node as import(\"typescript-next\").CommaListExpression);\n                return;\n            default:\n                if (node.kind >= ts.SyntaxKind.FirstToken && node.kind <= ts.SyntaxKind.LastToken) {\n                    writer.write(\"factory.createToken(ts.SyntaxKind.\").write(syntaxKindToName[node.kind]).write(\")\");\n                    return;\n                }\n                writer.write(\"/* Unhandled node kind: \").write(syntaxKindToName[node.kind]).write(\" */\")\n        }\n    }\n\n    function writeNodeTextForTypeNode(node: import(\"typescript-next\").TypeNode) {\n        if (node.kind >= ts.SyntaxKind.FirstKeyword && node.kind <= ts.SyntaxKind.LastKeyword) {\n            writer.write(\"factory.createKeywordTypeNode(ts.SyntaxKind.\").write(syntaxKindToName[node.kind]).write(\")\");\n        }\n        else {\n            writeNodeText(node);\n        }\n    }\n\n    function createNumericLiteral(node: import(\"typescript-next\").NumericLiteral) {\n        writer.write(\"factory.createNumericLiteral(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createBigIntLiteral(node: import(\"typescript-next\").BigIntLiteral) {\n        writer.write(\"factory.createBigIntLiteral(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createStringLiteral(node: import(\"typescript-next\").StringLiteral) {\n        writer.write(\"factory.createStringLiteral(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createRegularExpressionLiteral(node: import(\"typescript-next\").RegularExpressionLiteral) {\n        writer.write(\"factory.createRegularExpressionLiteral(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createIdentifier(node: import(\"typescript-next\").Identifier) {\n        writer.write(\"factory.createIdentifier(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createPrivateIdentifier(node: import(\"typescript-next\").PrivateIdentifier) {\n        writer.write(\"factory.createPrivateIdentifier(\");\n        writer.quote(node.text.toString())\n        writer.write(\")\");\n    }\n\n    function createSuper(node: import(\"typescript-next\").SuperExpression) {\n        writer.write(\"factory.createSuper(\");\n        writer.write(\")\");\n    }\n\n    function createThis(node: import(\"typescript-next\").ThisExpression) {\n        writer.write(\"factory.createThis(\");\n        writer.write(\")\");\n    }\n\n    function createNull(node: import(\"typescript-next\").NullLiteral) {\n        writer.write(\"factory.createNull(\");\n        writer.write(\")\");\n    }\n\n    function createTrue(node: import(\"typescript-next\").TrueLiteral) {\n        writer.write(\"factory.createTrue(\");\n        writer.write(\")\");\n    }\n\n    function createFalse(node: import(\"typescript-next\").FalseLiteral) {\n        writer.write(\"factory.createFalse(\");\n        writer.write(\")\");\n    }\n\n    function createQualifiedName(node: import(\"typescript-next\").QualifiedName) {\n        writer.write(\"factory.createQualifiedName(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.left)\n            writer.write(\",\").newLine();\n            writeNodeText(node.right)\n        });\n        writer.write(\")\");\n    }\n\n    function createComputedPropertyName(node: import(\"typescript-next\").ComputedPropertyName) {\n        writer.write(\"factory.createComputedPropertyName(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createTypeParameterDeclaration(node: import(\"typescript-next\").TypeParameterDeclaration) {\n        writer.write(\"factory.createTypeParameterDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.constraint == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.constraint)\n            }\n            writer.write(\",\").newLine();\n            if (node.default == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.default)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createParameterDeclaration(node: import(\"typescript-next\").ParameterDeclaration) {\n        writer.write(\"factory.createParameterDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.dotDotDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.dotDotDotToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createDecorator(node: import(\"typescript-next\").Decorator) {\n        writer.write(\"factory.createDecorator(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createPropertySignature(node: import(\"typescript-next\").PropertySignature) {\n        writer.write(\"factory.createPropertySignature(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createPropertyDeclaration(node: import(\"typescript-next\").PropertyDeclaration) {\n        writer.write(\"factory.createPropertyDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken != null)\n                writer.write(\"factory.createToken(ts.SyntaxKind.QuestionToken)\");\n            else if (node.exclamationToken != null)\n                writer.write(\"factory.createToken(ts.SyntaxKind.ExclamationToken)\");\n            else\n                writer.write(\"undefined\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createMethodSignature(node: import(\"typescript-next\").MethodSignature) {\n        writer.write(\"factory.createMethodSignature(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createMethodDeclaration(node: import(\"typescript-next\").MethodDeclaration) {\n        writer.write(\"factory.createMethodDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.asteriskToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.asteriskToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createConstructorDeclaration(node: import(\"typescript-next\").ConstructorDeclaration) {\n        writer.write(\"factory.createConstructorDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createGetAccessorDeclaration(node: import(\"typescript-next\").GetAccessorDeclaration) {\n        writer.write(\"factory.createGetAccessorDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createSetAccessorDeclaration(node: import(\"typescript-next\").SetAccessorDeclaration) {\n        writer.write(\"factory.createSetAccessorDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createCallSignature(node: import(\"typescript-next\").CallSignatureDeclaration) {\n        writer.write(\"factory.createCallSignature(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createConstructSignature(node: import(\"typescript-next\").ConstructSignatureDeclaration) {\n        writer.write(\"factory.createConstructSignature(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createIndexSignature(node: import(\"typescript-next\").IndexSignatureDeclaration) {\n        writer.write(\"factory.createIndexSignature(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateLiteralTypeSpan(node: import(\"typescript-next\").TemplateLiteralTypeSpan) {\n        writer.write(\"factory.createTemplateLiteralTypeSpan(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeTextForTypeNode(node.type)\n            writer.write(\",\").newLine();\n            writeNodeText(node.literal)\n        });\n        writer.write(\")\");\n    }\n\n    function createClassStaticBlockDeclaration(node: import(\"typescript-next\").ClassStaticBlockDeclaration) {\n        writer.write(\"factory.createClassStaticBlockDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.body)\n        });\n        writer.write(\")\");\n    }\n\n    function createKeywordTypeNode(node: import(\"typescript-next\").KeywordTypeNode) {\n        writer.write(\"factory.createKeywordTypeNode(\");\n        writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.kind])\n        writer.write(\")\");\n    }\n\n    function createTypeReferenceNode(node: import(\"typescript-next\").TypeReferenceNode) {\n        writer.write(\"factory.createTypeReferenceNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.typeName)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createFunctionTypeNode(node: import(\"typescript-next\").FunctionTypeNode) {\n        writer.write(\"factory.createFunctionTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createConstructorTypeNode(node: import(\"typescript-next\").ConstructorTypeNode) {\n        writer.write(\"factory.createConstructorTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createTypeQueryNode(node: import(\"typescript-next\").TypeQueryNode) {\n        writer.write(\"factory.createTypeQueryNode(\");\n        writeNodeText(node.exprName)\n        writer.write(\")\");\n    }\n\n    function createTypeLiteralNode(node: import(\"typescript-next\").TypeLiteralNode) {\n        writer.write(\"factory.createTypeLiteralNode(\");\n        writer.write(\"[\");\n        if (node.members.length === 1) {\n            const item = node.members![0];\n            writeNodeText(item)\n        }\n        else if (node.members.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.members!.length; i++) {\n                    const item = node.members![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createArrayTypeNode(node: import(\"typescript-next\").ArrayTypeNode) {\n        writer.write(\"factory.createArrayTypeNode(\");\n        writeNodeTextForTypeNode(node.elementType)\n        writer.write(\")\");\n    }\n\n    function createTupleTypeNode(node: import(\"typescript-next\").TupleTypeNode) {\n        writer.write(\"factory.createTupleTypeNode(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createNamedTupleMember(node: import(\"typescript-next\").NamedTupleMember) {\n        writer.write(\"factory.createNamedTupleMember(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.dotDotDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.dotDotDotToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createOptionalTypeNode(node: import(\"typescript-next\").OptionalTypeNode) {\n        writer.write(\"factory.createOptionalTypeNode(\");\n        writeNodeTextForTypeNode(node.type)\n        writer.write(\")\");\n    }\n\n    function createRestTypeNode(node: import(\"typescript-next\").RestTypeNode) {\n        writer.write(\"factory.createRestTypeNode(\");\n        writeNodeTextForTypeNode(node.type)\n        writer.write(\")\");\n    }\n\n    function createUnionTypeNode(node: import(\"typescript-next\").UnionTypeNode) {\n        writer.write(\"factory.createUnionTypeNode(\");\n        writer.write(\"[\");\n        if (node.types.length === 1) {\n            const item = node.types![0];\n            writeNodeTextForTypeNode(item)\n        }\n        else if (node.types.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.types!.length; i++) {\n                    const item = node.types![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeTextForTypeNode(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createIntersectionTypeNode(node: import(\"typescript-next\").IntersectionTypeNode) {\n        writer.write(\"factory.createIntersectionTypeNode(\");\n        writer.write(\"[\");\n        if (node.types.length === 1) {\n            const item = node.types![0];\n            writeNodeTextForTypeNode(item)\n        }\n        else if (node.types.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.types!.length; i++) {\n                    const item = node.types![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeTextForTypeNode(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createConditionalTypeNode(node: import(\"typescript-next\").ConditionalTypeNode) {\n        writer.write(\"factory.createConditionalTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeTextForTypeNode(node.checkType)\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.extendsType)\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.trueType)\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.falseType)\n        });\n        writer.write(\")\");\n    }\n\n    function createInferTypeNode(node: import(\"typescript-next\").InferTypeNode) {\n        writer.write(\"factory.createInferTypeNode(\");\n        writeNodeText(node.typeParameter)\n        writer.write(\")\");\n    }\n\n    function createImportTypeNode(node: import(\"typescript-next\").ImportTypeNode) {\n        writer.write(\"factory.createImportTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeTextForTypeNode(node.argument)\n            writer.write(\",\").newLine();\n            if (node.qualifier == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.qualifier)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(node.isTypeOf.toString())\n        });\n        writer.write(\")\");\n    }\n\n    function createParenthesizedType(node: import(\"typescript-next\").ParenthesizedTypeNode) {\n        writer.write(\"factory.createParenthesizedType(\");\n        writeNodeTextForTypeNode(node.type)\n        writer.write(\")\");\n    }\n\n    function createThisTypeNode(node: import(\"typescript-next\").ThisTypeNode) {\n        writer.write(\"factory.createThisTypeNode(\");\n        writer.write(\")\");\n    }\n\n    function createTypeOperatorNode(node: import(\"typescript-next\").TypeOperatorNode) {\n        writer.write(\"factory.createTypeOperatorNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.operator])\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createIndexedAccessTypeNode(node: import(\"typescript-next\").IndexedAccessTypeNode) {\n        writer.write(\"factory.createIndexedAccessTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeTextForTypeNode(node.objectType)\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.indexType)\n        });\n        writer.write(\")\");\n    }\n\n    function createMappedTypeNode(node: import(\"typescript-next\").MappedTypeNode) {\n        writer.write(\"factory.createMappedTypeNode(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.readonlyToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.readonlyToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.typeParameter)\n            writer.write(\",\").newLine();\n            if (node.nameType == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.nameType)\n            }\n            writer.write(\",\").newLine();\n            if (node.questionToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createLiteralTypeNode(node: import(\"typescript-next\").LiteralTypeNode) {\n        writer.write(\"factory.createLiteralTypeNode(\");\n        writeNodeText(node.literal)\n        writer.write(\")\");\n    }\n\n    function createTemplateLiteralType(node: import(\"typescript-next\").TemplateLiteralTypeNode) {\n        writer.write(\"factory.createTemplateLiteralType(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.head)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.templateSpans.length === 1) {\n                const item = node.templateSpans![0];\n                writeNodeText(item)\n            }\n            else if (node.templateSpans.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.templateSpans!.length; i++) {\n                        const item = node.templateSpans![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createObjectBindingPattern(node: import(\"typescript-next\").ObjectBindingPattern) {\n        writer.write(\"factory.createObjectBindingPattern(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createArrayBindingPattern(node: import(\"typescript-next\").ArrayBindingPattern) {\n        writer.write(\"factory.createArrayBindingPattern(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createBindingElement(node: import(\"typescript-next\").BindingElement) {\n        writer.write(\"factory.createBindingElement(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.dotDotDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.dotDotDotToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.propertyName == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.propertyName)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createArrayLiteralExpression(node: import(\"typescript-next\").ArrayLiteralExpression) {\n        writer.write(\"factory.createArrayLiteralExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"[\");\n            if (node.elements.length === 1) {\n                const item = node.elements![0];\n                writeNodeText(item)\n            }\n            else if (node.elements.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.elements!.length; i++) {\n                        const item = node.elements![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writer.write(((node as any).multiLine || false).toString())\n        });\n        writer.write(\")\");\n    }\n\n    function createObjectLiteralExpression(node: import(\"typescript-next\").ObjectLiteralExpression) {\n        writer.write(\"factory.createObjectLiteralExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"[\");\n            if (node.properties.length === 1) {\n                const item = node.properties![0];\n                writeNodeText(item)\n            }\n            else if (node.properties.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.properties!.length; i++) {\n                        const item = node.properties![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writer.write(((node as any).multiLine || false).toString())\n        });\n        writer.write(\")\");\n    }\n\n    function createPropertyAccessExpression(node: import(\"typescript-next\").PropertyAccessExpression) {\n        writer.write(\"factory.createPropertyAccessExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n        });\n        writer.write(\")\");\n    }\n\n    function createPropertyAccessChain(node: import(\"typescript-next\").PropertyAccessChain) {\n        writer.write(\"factory.createPropertyAccessChain(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.questionDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionDotToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n        });\n        writer.write(\")\");\n    }\n\n    function createElementAccessExpression(node: import(\"typescript-next\").ElementAccessExpression) {\n        writer.write(\"factory.createElementAccessExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.argumentExpression)\n        });\n        writer.write(\")\");\n    }\n\n    function createElementAccessChain(node: import(\"typescript-next\").ElementAccessChain) {\n        writer.write(\"factory.createElementAccessChain(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.questionDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionDotToken)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.argumentExpression)\n        });\n        writer.write(\")\");\n    }\n\n    function createCallExpression(node: import(\"typescript-next\").CallExpression) {\n        writer.write(\"factory.createCallExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.arguments.length === 1) {\n                const item = node.arguments![0];\n                writeNodeText(item)\n            }\n            else if (node.arguments.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.arguments!.length; i++) {\n                        const item = node.arguments![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createCallChain(node: import(\"typescript-next\").CallChain) {\n        writer.write(\"factory.createCallChain(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.questionDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.questionDotToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.arguments.length === 1) {\n                const item = node.arguments![0];\n                writeNodeText(item)\n            }\n            else if (node.arguments.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.arguments!.length; i++) {\n                        const item = node.arguments![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createNewExpression(node: import(\"typescript-next\").NewExpression) {\n        writer.write(\"factory.createNewExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.arguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.arguments.length === 1) {\n                    const item = node.arguments![0];\n                    writeNodeText(item)\n                }\n                else if (node.arguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.arguments!.length; i++) {\n                            const item = node.arguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createTaggedTemplateExpression(node: import(\"typescript-next\").TaggedTemplateExpression) {\n        writer.write(\"factory.createTaggedTemplateExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.tag)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.template)\n        });\n        writer.write(\")\");\n    }\n\n    function createTypeAssertion(node: import(\"typescript-next\").TypeAssertion) {\n        writer.write(\"factory.createTypeAssertion(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeTextForTypeNode(node.type)\n            writer.write(\",\").newLine();\n            writeNodeText(node.expression)\n        });\n        writer.write(\")\");\n    }\n\n    function createParenthesizedExpression(node: import(\"typescript-next\").ParenthesizedExpression) {\n        writer.write(\"factory.createParenthesizedExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createFunctionExpression(node: import(\"typescript-next\").FunctionExpression) {\n        writer.write(\"factory.createFunctionExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.asteriskToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.asteriskToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.name == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.name)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.body)\n        });\n        writer.write(\")\");\n    }\n\n    function createArrowFunction(node: import(\"typescript-next\").ArrowFunction) {\n        writer.write(\"factory.createArrowFunction(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.equalsGreaterThanToken)\n            writer.write(\",\").newLine();\n            writeNodeText(node.body)\n        });\n        writer.write(\")\");\n    }\n\n    function createDeleteExpression(node: import(\"typescript-next\").DeleteExpression) {\n        writer.write(\"factory.createDeleteExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createTypeOfExpression(node: import(\"typescript-next\").TypeOfExpression) {\n        writer.write(\"factory.createTypeOfExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createVoidExpression(node: import(\"typescript-next\").VoidExpression) {\n        writer.write(\"factory.createVoidExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createAwaitExpression(node: import(\"typescript-next\").AwaitExpression) {\n        writer.write(\"factory.createAwaitExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createPrefixUnaryExpression(node: import(\"typescript-next\").PrefixUnaryExpression) {\n        writer.write(\"factory.createPrefixUnaryExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.operator])\n            writer.write(\",\").newLine();\n            writeNodeText(node.operand)\n        });\n        writer.write(\")\");\n    }\n\n    function createPostfixUnaryExpression(node: import(\"typescript-next\").PostfixUnaryExpression) {\n        writer.write(\"factory.createPostfixUnaryExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.operand)\n            writer.write(\",\").newLine();\n            writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.operator])\n        });\n        writer.write(\")\");\n    }\n\n    function createBinaryExpression(node: import(\"typescript-next\").BinaryExpression) {\n        writer.write(\"factory.createBinaryExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.left)\n            writer.write(\",\").newLine();\n            writeNodeText(node.operatorToken)\n            writer.write(\",\").newLine();\n            writeNodeText(node.right)\n        });\n        writer.write(\")\");\n    }\n\n    function createConditionalExpression(node: import(\"typescript-next\").ConditionalExpression) {\n        writer.write(\"factory.createConditionalExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.condition)\n            writer.write(\",\").newLine();\n            writeNodeText(node.questionToken)\n            writer.write(\",\").newLine();\n            writeNodeText(node.whenTrue)\n            writer.write(\",\").newLine();\n            writeNodeText(node.colonToken)\n            writer.write(\",\").newLine();\n            writeNodeText(node.whenFalse)\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateExpression(node: import(\"typescript-next\").TemplateExpression) {\n        writer.write(\"factory.createTemplateExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.head)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.templateSpans.length === 1) {\n                const item = node.templateSpans![0];\n                writeNodeText(item)\n            }\n            else if (node.templateSpans.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.templateSpans!.length; i++) {\n                        const item = node.templateSpans![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateHead(node: import(\"typescript-next\").TemplateHead) {\n        writer.write(\"factory.createTemplateHead(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.quote(node.text.toString())\n            writer.write(\",\").newLine();\n            if (node.rawText == null)\n                writer.write(\"undefined\");\n            else {\n                writer.quote(node.rawText.toString())\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateMiddle(node: import(\"typescript-next\").TemplateMiddle) {\n        writer.write(\"factory.createTemplateMiddle(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.quote(node.text.toString())\n            writer.write(\",\").newLine();\n            if (node.rawText == null)\n                writer.write(\"undefined\");\n            else {\n                writer.quote(node.rawText.toString())\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateTail(node: import(\"typescript-next\").TemplateTail) {\n        writer.write(\"factory.createTemplateTail(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.quote(node.text.toString())\n            writer.write(\",\").newLine();\n            if (node.rawText == null)\n                writer.write(\"undefined\");\n            else {\n                writer.quote(node.rawText.toString())\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createNoSubstitutionTemplateLiteral(node: import(\"typescript-next\").NoSubstitutionTemplateLiteral) {\n        writer.write(\"factory.createNoSubstitutionTemplateLiteral(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.quote(node.text.toString())\n            writer.write(\",\").newLine();\n            if (node.rawText == null)\n                writer.write(\"undefined\");\n            else {\n                writer.quote(node.rawText.toString())\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createYieldExpression(node: import(\"typescript-next\").YieldExpression) {\n        writer.write(\"factory.createYieldExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.asteriskToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.asteriskToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.expression == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.expression)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createSpreadElement(node: import(\"typescript-next\").SpreadElement) {\n        writer.write(\"factory.createSpreadElement(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createClassExpression(node: import(\"typescript-next\").ClassExpression) {\n        writer.write(\"factory.createClassExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.name == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.name)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.heritageClauses == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.heritageClauses.length === 1) {\n                    const item = node.heritageClauses![0];\n                    writeNodeText(item)\n                }\n                else if (node.heritageClauses.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.heritageClauses!.length; i++) {\n                            const item = node.heritageClauses![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.members.length === 1) {\n                const item = node.members![0];\n                writeNodeText(item)\n            }\n            else if (node.members.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.members!.length; i++) {\n                        const item = node.members![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createOmittedExpression(node: import(\"typescript-next\").OmittedExpression) {\n        writer.write(\"factory.createOmittedExpression(\");\n        writer.write(\")\");\n    }\n\n    function createExpressionWithTypeArguments(node: import(\"typescript-next\").ExpressionWithTypeArguments) {\n        writer.write(\"factory.createExpressionWithTypeArguments(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createAsExpression(node: import(\"typescript-next\").AsExpression) {\n        writer.write(\"factory.createAsExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createNonNullExpression(node: import(\"typescript-next\").NonNullExpression) {\n        writer.write(\"factory.createNonNullExpression(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createNonNullChain(node: import(\"typescript-next\").NonNullChain) {\n        writer.write(\"factory.createNonNullChain(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createMetaProperty(node: import(\"typescript-next\").MetaProperty) {\n        writer.write(\"factory.createMetaProperty(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.keywordToken])\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n        });\n        writer.write(\")\");\n    }\n\n    function createTemplateSpan(node: import(\"typescript-next\").TemplateSpan) {\n        writer.write(\"factory.createTemplateSpan(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.literal)\n        });\n        writer.write(\")\");\n    }\n\n    function createSemicolonClassElement(node: import(\"typescript-next\").SemicolonClassElement) {\n        writer.write(\"factory.createSemicolonClassElement(\");\n        writer.write(\")\");\n    }\n\n    function createBlock(node: import(\"typescript-next\").Block) {\n        writer.write(\"factory.createBlock(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"[\");\n            if (node.statements.length === 1) {\n                const item = node.statements![0];\n                writeNodeText(item)\n            }\n            else if (node.statements.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.statements!.length; i++) {\n                        const item = node.statements![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writer.write(((node as any).multiLine || false).toString())\n        });\n        writer.write(\")\");\n    }\n\n    function createVariableStatement(node: import(\"typescript-next\").VariableStatement) {\n        writer.write(\"factory.createVariableStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.declarationList)\n        });\n        writer.write(\")\");\n    }\n\n    function createEmptyStatement(node: import(\"typescript-next\").EmptyStatement) {\n        writer.write(\"factory.createEmptyStatement(\");\n        writer.write(\")\");\n    }\n\n    function createExpressionStatement(node: import(\"typescript-next\").ExpressionStatement) {\n        writer.write(\"factory.createExpressionStatement(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createIfStatement(node: import(\"typescript-next\").IfStatement) {\n        writer.write(\"factory.createIfStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.thenStatement)\n            writer.write(\",\").newLine();\n            if (node.elseStatement == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.elseStatement)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createDoStatement(node: import(\"typescript-next\").DoStatement) {\n        writer.write(\"factory.createDoStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.statement)\n            writer.write(\",\").newLine();\n            writeNodeText(node.expression)\n        });\n        writer.write(\")\");\n    }\n\n    function createWhileStatement(node: import(\"typescript-next\").WhileStatement) {\n        writer.write(\"factory.createWhileStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createForStatement(node: import(\"typescript-next\").ForStatement) {\n        writer.write(\"factory.createForStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n            writer.write(\",\").newLine();\n            if (node.condition == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.condition)\n            }\n            writer.write(\",\").newLine();\n            if (node.incrementor == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.incrementor)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createForInStatement(node: import(\"typescript-next\").ForInStatement) {\n        writer.write(\"factory.createForInStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.initializer)\n            writer.write(\",\").newLine();\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createForOfStatement(node: import(\"typescript-next\").ForOfStatement) {\n        writer.write(\"factory.createForOfStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.awaitModifier == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.awaitModifier)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.initializer)\n            writer.write(\",\").newLine();\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createContinueStatement(node: import(\"typescript-next\").ContinueStatement) {\n        writer.write(\"factory.createContinueStatement(\");\n        if (node.label == null)\n            writer.write(\"undefined\");\n        else {\n            writeNodeText(node.label)\n        }\n        writer.write(\")\");\n    }\n\n    function createBreakStatement(node: import(\"typescript-next\").BreakStatement) {\n        writer.write(\"factory.createBreakStatement(\");\n        if (node.label == null)\n            writer.write(\"undefined\");\n        else {\n            writeNodeText(node.label)\n        }\n        writer.write(\")\");\n    }\n\n    function createReturnStatement(node: import(\"typescript-next\").ReturnStatement) {\n        writer.write(\"factory.createReturnStatement(\");\n        if (node.expression == null)\n            writer.write(\"undefined\");\n        else {\n            writeNodeText(node.expression)\n        }\n        writer.write(\")\");\n    }\n\n    function createWithStatement(node: import(\"typescript-next\").WithStatement) {\n        writer.write(\"factory.createWithStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createSwitchStatement(node: import(\"typescript-next\").SwitchStatement) {\n        writer.write(\"factory.createSwitchStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writeNodeText(node.caseBlock)\n        });\n        writer.write(\")\");\n    }\n\n    function createLabeledStatement(node: import(\"typescript-next\").LabeledStatement) {\n        writer.write(\"factory.createLabeledStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.label)\n            writer.write(\",\").newLine();\n            writeNodeText(node.statement)\n        });\n        writer.write(\")\");\n    }\n\n    function createThrowStatement(node: import(\"typescript-next\").ThrowStatement) {\n        writer.write(\"factory.createThrowStatement(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createTryStatement(node: import(\"typescript-next\").TryStatement) {\n        writer.write(\"factory.createTryStatement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.tryBlock)\n            writer.write(\",\").newLine();\n            if (node.catchClause == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.catchClause)\n            }\n            writer.write(\",\").newLine();\n            if (node.finallyBlock == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.finallyBlock)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createDebuggerStatement(node: import(\"typescript-next\").DebuggerStatement) {\n        writer.write(\"factory.createDebuggerStatement(\");\n        writer.write(\")\");\n    }\n\n    function createVariableDeclaration(node: import(\"typescript-next\").VariableDeclaration) {\n        writer.write(\"factory.createVariableDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.exclamationToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.exclamationToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createVariableDeclarationList(node: import(\"typescript-next\").VariableDeclarationList) {\n        writer.write(\"factory.createVariableDeclarationList(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"[\");\n            if (node.declarations.length === 1) {\n                const item = node.declarations![0];\n                writeNodeText(item)\n            }\n            else if (node.declarations.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.declarations!.length; i++) {\n                        const item = node.declarations![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writer.write(getNodeFlagValues(node.flags || 0));\n        });\n        writer.write(\")\");\n    }\n\n    function createFunctionDeclaration(node: import(\"typescript-next\").FunctionDeclaration) {\n        writer.write(\"factory.createFunctionDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.asteriskToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.asteriskToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.name == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.name)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.parameters.length === 1) {\n                const item = node.parameters![0];\n                writeNodeText(item)\n            }\n            else if (node.parameters.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.parameters!.length; i++) {\n                        const item = node.parameters![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            if (node.type == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeTextForTypeNode(node.type)\n            }\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createClassDeclaration(node: import(\"typescript-next\").ClassDeclaration) {\n        writer.write(\"factory.createClassDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.name == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.name)\n            }\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.heritageClauses == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.heritageClauses.length === 1) {\n                    const item = node.heritageClauses![0];\n                    writeNodeText(item)\n                }\n                else if (node.heritageClauses.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.heritageClauses!.length; i++) {\n                            const item = node.heritageClauses![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.members.length === 1) {\n                const item = node.members![0];\n                writeNodeText(item)\n            }\n            else if (node.members.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.members!.length; i++) {\n                        const item = node.members![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createInterfaceDeclaration(node: import(\"typescript-next\").InterfaceDeclaration) {\n        writer.write(\"factory.createInterfaceDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.heritageClauses == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.heritageClauses.length === 1) {\n                    const item = node.heritageClauses![0];\n                    writeNodeText(item)\n                }\n                else if (node.heritageClauses.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.heritageClauses!.length; i++) {\n                            const item = node.heritageClauses![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.members.length === 1) {\n                const item = node.members![0];\n                writeNodeText(item)\n            }\n            else if (node.members.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.members!.length; i++) {\n                        const item = node.members![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createTypeAliasDeclaration(node: import(\"typescript-next\").TypeAliasDeclaration) {\n        writer.write(\"factory.createTypeAliasDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.typeParameters == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeParameters.length === 1) {\n                    const item = node.typeParameters![0];\n                    writeNodeText(item)\n                }\n                else if (node.typeParameters.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeParameters!.length; i++) {\n                            const item = node.typeParameters![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeTextForTypeNode(node.type)\n        });\n        writer.write(\")\");\n    }\n\n    function createEnumDeclaration(node: import(\"typescript-next\").EnumDeclaration) {\n        writer.write(\"factory.createEnumDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.members.length === 1) {\n                const item = node.members![0];\n                writeNodeText(item)\n            }\n            else if (node.members.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.members!.length; i++) {\n                        const item = node.members![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createModuleDeclaration(node: import(\"typescript-next\").ModuleDeclaration) {\n        writer.write(\"factory.createModuleDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.body == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.body)\n            }\n            writer.write(\",\").newLine();\n            writer.write(getNodeFlagValues(node.flags || 0));\n        });\n        writer.write(\")\");\n    }\n\n    function createModuleBlock(node: import(\"typescript-next\").ModuleBlock) {\n        writer.write(\"factory.createModuleBlock(\");\n        writer.write(\"[\");\n        if (node.statements.length === 1) {\n            const item = node.statements![0];\n            writeNodeText(item)\n        }\n        else if (node.statements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.statements!.length; i++) {\n                    const item = node.statements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createCaseBlock(node: import(\"typescript-next\").CaseBlock) {\n        writer.write(\"factory.createCaseBlock(\");\n        writer.write(\"[\");\n        if (node.clauses.length === 1) {\n            const item = node.clauses![0];\n            writeNodeText(item)\n        }\n        else if (node.clauses.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.clauses!.length; i++) {\n                    const item = node.clauses![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createNamespaceExportDeclaration(node: import(\"typescript-next\").NamespaceExportDeclaration) {\n        writer.write(\"factory.createNamespaceExportDeclaration(\");\n        writeNodeText(node.name)\n        writer.write(\")\");\n    }\n\n    function createImportEqualsDeclaration(node: import(\"typescript-next\").ImportEqualsDeclaration) {\n        writer.write(\"factory.createImportEqualsDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(node.isTypeOnly.toString())\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writeNodeText(node.moduleReference)\n        });\n        writer.write(\")\");\n    }\n\n    function createImportDeclaration(node: import(\"typescript-next\").ImportDeclaration) {\n        writer.write(\"factory.createImportDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.importClause == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.importClause)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.moduleSpecifier)\n            writer.write(\",\").newLine();\n            if (node.assertClause == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.assertClause)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createImportClause(node: import(\"typescript-next\").ImportClause) {\n        writer.write(\"factory.createImportClause(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(node.isTypeOnly.toString())\n            writer.write(\",\").newLine();\n            if (node.name == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.name)\n            }\n            writer.write(\",\").newLine();\n            if (node.namedBindings == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.namedBindings)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createAssertClause(node: import(\"typescript-next\").AssertClause) {\n        writer.write(\"factory.createAssertClause(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"/* unknown */\")\n            writer.write(\",\").newLine();\n            if (node.multiLine == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(node.multiLine.toString())\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createAssertEntry(node: import(\"typescript-next\").AssertEntry) {\n        writer.write(\"factory.createAssertEntry(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writeNodeText(node.value)\n        });\n        writer.write(\")\");\n    }\n\n    function createNamespaceImport(node: import(\"typescript-next\").NamespaceImport) {\n        writer.write(\"factory.createNamespaceImport(\");\n        writeNodeText(node.name)\n        writer.write(\")\");\n    }\n\n    function createNamespaceExport(node: import(\"typescript-next\").NamespaceExport) {\n        writer.write(\"factory.createNamespaceExport(\");\n        writeNodeText(node.name)\n        writer.write(\")\");\n    }\n\n    function createNamedImports(node: import(\"typescript-next\").NamedImports) {\n        writer.write(\"factory.createNamedImports(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createImportSpecifier(node: import(\"typescript-next\").ImportSpecifier) {\n        writer.write(\"factory.createImportSpecifier(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.propertyName == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.propertyName)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n        });\n        writer.write(\")\");\n    }\n\n    function createExportAssignment(node: import(\"typescript-next\").ExportAssignment) {\n        writer.write(\"factory.createExportAssignment(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.isExportEquals == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(node.isExportEquals.toString())\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.expression)\n        });\n        writer.write(\")\");\n    }\n\n    function createExportDeclaration(node: import(\"typescript-next\").ExportDeclaration) {\n        writer.write(\"factory.createExportDeclaration(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.decorators == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.decorators.length === 1) {\n                    const item = node.decorators![0];\n                    writeNodeText(item)\n                }\n                else if (node.decorators.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.decorators!.length; i++) {\n                            const item = node.decorators![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeText(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            if (node.modifiers == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.modifiers.length === 1) {\n                    const item = node.modifiers![0];\n                    writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                }\n                else if (node.modifiers.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.modifiers!.length; i++) {\n                            const item = node.modifiers![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writer.write(\"factory.createModifier(ts.SyntaxKind.\" + syntaxKindToName[item.kind] + \")\");\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writer.write(node.isTypeOnly.toString())\n            writer.write(\",\").newLine();\n            if (node.exportClause == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.exportClause)\n            }\n            writer.write(\",\").newLine();\n            if (node.moduleSpecifier == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.moduleSpecifier)\n            }\n            writer.write(\",\").newLine();\n            if (node.assertClause == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.assertClause)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createNamedExports(node: import(\"typescript-next\").NamedExports) {\n        writer.write(\"factory.createNamedExports(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createExportSpecifier(node: import(\"typescript-next\").ExportSpecifier) {\n        writer.write(\"factory.createExportSpecifier(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.propertyName == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.propertyName)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.name)\n        });\n        writer.write(\")\");\n    }\n\n    function createExternalModuleReference(node: import(\"typescript-next\").ExternalModuleReference) {\n        writer.write(\"factory.createExternalModuleReference(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createJsxElement(node: import(\"typescript-next\").JsxElement) {\n        writer.write(\"factory.createJsxElement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.openingElement)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.children.length === 1) {\n                const item = node.children![0];\n                writeNodeText(item)\n            }\n            else if (node.children.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.children!.length; i++) {\n                        const item = node.children![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writeNodeText(node.closingElement)\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxSelfClosingElement(node: import(\"typescript-next\").JsxSelfClosingElement) {\n        writer.write(\"factory.createJsxSelfClosingElement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.tagName)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.attributes)\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxOpeningElement(node: import(\"typescript-next\").JsxOpeningElement) {\n        writer.write(\"factory.createJsxOpeningElement(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.tagName)\n            writer.write(\",\").newLine();\n            if (node.typeArguments == null)\n                writer.write(\"undefined\");\n            else {\n                writer.write(\"[\");\n                if (node.typeArguments.length === 1) {\n                    const item = node.typeArguments![0];\n                    writeNodeTextForTypeNode(item)\n                }\n                else if (node.typeArguments.length > 1) {\n                    writer.indent(() => {\n                        for (let i = 0; i < node.typeArguments!.length; i++) {\n                            const item = node.typeArguments![i];\n                            if (i > 0)\n                                writer.write(\",\").newLine();\n                            writeNodeTextForTypeNode(item)\n                        }\n                    });\n                }\n                writer.write(\"]\");\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.attributes)\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxClosingElement(node: import(\"typescript-next\").JsxClosingElement) {\n        writer.write(\"factory.createJsxClosingElement(\");\n        writeNodeText(node.tagName)\n        writer.write(\")\");\n    }\n\n    function createJsxFragment(node: import(\"typescript-next\").JsxFragment) {\n        writer.write(\"factory.createJsxFragment(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.openingFragment)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.children.length === 1) {\n                const item = node.children![0];\n                writeNodeText(item)\n            }\n            else if (node.children.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.children!.length; i++) {\n                        const item = node.children![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n            writer.write(\",\").newLine();\n            writeNodeText(node.closingFragment)\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxText(node: import(\"typescript-next\").JsxText) {\n        writer.write(\"factory.createJsxText(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.quote(node.text.toString())\n            writer.write(\",\").newLine();\n            writer.write(node.containsOnlyTriviaWhiteSpaces.toString())\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxOpeningFragment(node: import(\"typescript-next\").JsxOpeningFragment) {\n        writer.write(\"factory.createJsxOpeningFragment(\");\n        writer.write(\")\");\n    }\n\n    function createJsxJsxClosingFragment(node: import(\"typescript-next\").JsxClosingFragment) {\n        writer.write(\"factory.createJsxJsxClosingFragment(\");\n        writer.write(\")\");\n    }\n\n    function createJsxAttribute(node: import(\"typescript-next\").JsxAttribute) {\n        writer.write(\"factory.createJsxAttribute(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createJsxAttributes(node: import(\"typescript-next\").JsxAttributes) {\n        writer.write(\"factory.createJsxAttributes(\");\n        writer.write(\"[\");\n        if (node.properties.length === 1) {\n            const item = node.properties![0];\n            writeNodeText(item)\n        }\n        else if (node.properties.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.properties!.length; i++) {\n                    const item = node.properties![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createJsxSpreadAttribute(node: import(\"typescript-next\").JsxSpreadAttribute) {\n        writer.write(\"factory.createJsxSpreadAttribute(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createJsxExpression(node: import(\"typescript-next\").JsxExpression) {\n        writer.write(\"factory.createJsxExpression(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.dotDotDotToken == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.dotDotDotToken)\n            }\n            writer.write(\",\").newLine();\n            if (node.expression == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.expression)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createCaseClause(node: import(\"typescript-next\").CaseClause) {\n        writer.write(\"factory.createCaseClause(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.expression)\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.statements.length === 1) {\n                const item = node.statements![0];\n                writeNodeText(item)\n            }\n            else if (node.statements.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.statements!.length; i++) {\n                        const item = node.statements![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createDefaultClause(node: import(\"typescript-next\").DefaultClause) {\n        writer.write(\"factory.createDefaultClause(\");\n        writer.write(\"[\");\n        if (node.statements.length === 1) {\n            const item = node.statements![0];\n            writeNodeText(item)\n        }\n        else if (node.statements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.statements!.length; i++) {\n                    const item = node.statements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createHeritageClause(node: import(\"typescript-next\").HeritageClause) {\n        writer.write(\"factory.createHeritageClause(\");\n        writer.newLine();\n        writer.indent(() => {\n            writer.write(\"ts.SyntaxKind.\").write(syntaxKindToName[node.token])\n            writer.write(\",\").newLine();\n            writer.write(\"[\");\n            if (node.types.length === 1) {\n                const item = node.types![0];\n                writeNodeText(item)\n            }\n            else if (node.types.length > 1) {\n                writer.indent(() => {\n                    for (let i = 0; i < node.types!.length; i++) {\n                        const item = node.types![i];\n                        if (i > 0)\n                            writer.write(\",\").newLine();\n                        writeNodeText(item)\n                    }\n                });\n            }\n            writer.write(\"]\");\n        });\n        writer.write(\")\");\n    }\n\n    function createCatchClause(node: import(\"typescript-next\").CatchClause) {\n        writer.write(\"factory.createCatchClause(\");\n        writer.newLine();\n        writer.indent(() => {\n            if (node.variableDeclaration == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.variableDeclaration)\n            }\n            writer.write(\",\").newLine();\n            writeNodeText(node.block)\n        });\n        writer.write(\")\");\n    }\n\n    function createPropertyAssignment(node: import(\"typescript-next\").PropertyAssignment) {\n        writer.write(\"factory.createPropertyAssignment(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            writeNodeText(node.initializer)\n        });\n        writer.write(\")\");\n    }\n\n    function createShorthandPropertyAssignment(node: import(\"typescript-next\").ShorthandPropertyAssignment) {\n        writer.write(\"factory.createShorthandPropertyAssignment(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.objectAssignmentInitializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.objectAssignmentInitializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createSpreadAssignment(node: import(\"typescript-next\").SpreadAssignment) {\n        writer.write(\"factory.createSpreadAssignment(\");\n        writeNodeText(node.expression)\n        writer.write(\")\");\n    }\n\n    function createEnumMember(node: import(\"typescript-next\").EnumMember) {\n        writer.write(\"factory.createEnumMember(\");\n        writer.newLine();\n        writer.indent(() => {\n            writeNodeText(node.name)\n            writer.write(\",\").newLine();\n            if (node.initializer == null)\n                writer.write(\"undefined\");\n            else {\n                writeNodeText(node.initializer)\n            }\n        });\n        writer.write(\")\");\n    }\n\n    function createCommaListExpression(node: import(\"typescript-next\").CommaListExpression) {\n        writer.write(\"factory.createCommaListExpression(\");\n        writer.write(\"[\");\n        if (node.elements.length === 1) {\n            const item = node.elements![0];\n            writeNodeText(item)\n        }\n        else if (node.elements.length > 1) {\n            writer.indent(() => {\n                for (let i = 0; i < node.elements!.length; i++) {\n                    const item = node.elements![i];\n                    if (i > 0)\n                        writer.write(\",\").newLine();\n                    writeNodeText(item)\n                }\n            });\n        }\n        writer.write(\"]\");\n        writer.write(\")\");\n    }\n\n    function createSyntaxKindToNameMap() {\n        const map: { [kind: number]: string } = {};\n        for (const name of Object.keys(ts.SyntaxKind).filter(k => isNaN(parseInt(k, 10)))) {\n            const value = (ts.SyntaxKind as any)[name] as number;\n            if (map[value] == null)\n                map[value] = name;\n        }\n        return map;\n    }\n\n    function getNodeFlagValues(value: number) {\n        // ignore the BlockScoped node flag\n        return getFlagValuesAsString(ts.NodeFlags, \"ts.NodeFlags\", value || 0, \"None\", getFlagValues(ts.NodeFlags, value).filter(v => v !== ts.NodeFlags.BlockScoped));\n    }\n\n    function getFlagValuesAsString(enumObj: any, enumName: string, value: number, defaultName: string, flagValues?: number[]) {\n        flagValues = flagValues || getFlagValues(enumObj, value);\n        const members: string[] = [];\n        for (const flagValue of flagValues)\n            members.push(enumName + \".\" + enumObj[flagValue]);\n        if (members.length === 0)\n            members.push(enumName + \".\" + defaultName);\n        return members.join(\" | \");\n    }\n\n    function getFlagValues(enumObj: any, value: number) {\n        const members: number[] = [];\n        for (const prop in enumObj) {\n            if (typeof enumObj[prop] === \"string\")\n                continue;\n            if ((enumObj[prop] & value) !== 0)\n                members.push(enumObj[prop]);\n        }\n        return members;\n    }\n}\n"],"sourceRoot":""}