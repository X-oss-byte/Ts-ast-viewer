{"version":3,"sources":["../../node_modules/code-block-writer/dist/code-block-writer.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js","../../node_modules/code-block-writer/dist/utils/stringUtils.js","../../node_modules/code-block-writer/dist/CommentChar.js"],"names":["Object","defineProperty","exports","value","stringUtils_1","require","CommentChar_1","CHARS","BACK_SLASH","charCodeAt","FORWARD_SLASH","NEW_LINE","CARRIAGE_RETURN","ASTERISK","DOUBLE_QUOTE","SINGLE_QUOTE","BACK_TICK","OPEN_BRACE","CLOSE_BRACE","DOLLAR_SIGN","isCharToHandle","Set","CodeBlockWriter","opts","this","_currentIndentation","_length","_newLineOnNextWrite","_currentCommentChar","undefined","_stringCharStack","_isInRegEx","_isOnFirstLineOfBlock","_texts","_newLine","newLine","_useTabs","useTabs","_indentNumberOfSpaces","indentNumberOfSpaces","_indentationText","getIndentationText","_quoteChar","useSingleQuote","countOrText","_queuedIndentation","_getIndentationLevelFromArg","_queuedOnlyIfNotBlock","action","_withResetIndentation","queueIndentationLevel","getIndentationLevel","setIndentationLevel","setStateAction","writeAction","previousState","_getIndentationState","_setIndentationState","block","_newLineIfNewLineOnNextWrite","getLength","isLastNewLine","spaceIfLastNot","inlineBlock","write","_indentBlockInternal","newLineIfLastNot","timesOrBlock","repeat","getLastChar","Math","max","condition","strOrFunc","writeLine","getStringFromStrOrFunc","text","_writeIndentingNewLines","isLastBlankLine","blankLine","_baseWriteNewline","escapeForWithinString","isLastSpace","times","isLastTab","textOrFunc","commentChar","CommentChar","Line","Star","pos","textLength","texts","Error","verifyInput","endPos","i","length","startPos","index","localIndex","getArrayIndexAndLocalIndex","splice","textItem","startText","substring","endText","updateInternalArray","isOnFirstLineOfBlock","lastChar","foundCount","currentText","j","currentChar","charCode","_getLastCharCodeWithOffset","String","fromCharCode","iterateLastCharCodes","offset","textIndex","result","join","push","split","_newLineRegEx","forEach","s","writeIndividual","writer","isInString","_writeIndentation","_updateInternalState","_internalWrite","lastStringCharOnStack","pop","_dequeueQueuedIndentation","foundNewLine","wasLastBlock","str","has","pastChar","pastPastChar","isInComment","isRegExStart","flooredIndentation","floor","overflow","portion","round","_spacesOrTabsRegEx","test","spacesCount","tabsCount","char","getSpacesAndTabsCount","state","current","queued","queuedOnlyIfNotBlock","numberSpaces","Array","default","unsupportedIterableToArray","module","o","allowArrayLike","it","Symbol","iterator","isArray","F","n","done","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","arrayLikeToArray","minLen","prototype","toString","call","slice","constructor","name","from","arr","len","arr2","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","escapeChar","newlineRegex","quoteKind","replace","Function"],"mappings":"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","file":"static/js/0.c0f401eb.chunk.js","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stringUtils_1 = require(\"./utils/stringUtils\");\r\nconst CommentChar_1 = require(\"./CommentChar\");\r\n// Using the char codes is a performance improvement (about 5.5% faster when writing because it eliminates additional string allocations).\r\nconst CHARS = {\r\n    BACK_SLASH: \"\\\\\".charCodeAt(0),\r\n    FORWARD_SLASH: \"/\".charCodeAt(0),\r\n    NEW_LINE: \"\\n\".charCodeAt(0),\r\n    CARRIAGE_RETURN: \"\\r\".charCodeAt(0),\r\n    ASTERISK: \"*\".charCodeAt(0),\r\n    DOUBLE_QUOTE: \"\\\"\".charCodeAt(0),\r\n    SINGLE_QUOTE: \"'\".charCodeAt(0),\r\n    BACK_TICK: \"`\".charCodeAt(0),\r\n    OPEN_BRACE: \"{\".charCodeAt(0),\r\n    CLOSE_BRACE: \"}\".charCodeAt(0),\r\n    DOLLAR_SIGN: \"$\".charCodeAt(0),\r\n};\r\nconst isCharToHandle = new Set([\r\n    CHARS.BACK_SLASH,\r\n    CHARS.FORWARD_SLASH,\r\n    CHARS.NEW_LINE,\r\n    CHARS.CARRIAGE_RETURN,\r\n    CHARS.ASTERISK,\r\n    CHARS.DOUBLE_QUOTE,\r\n    CHARS.SINGLE_QUOTE,\r\n    CHARS.BACK_TICK,\r\n    CHARS.OPEN_BRACE,\r\n    CHARS.CLOSE_BRACE,\r\n]);\r\n/**\r\n * Code writer that assists with formatting and visualizing blocks of JavaScript or TypeScript code.\r\n */\r\nclass CodeBlockWriter {\r\n    /**\r\n     * Constructor.\r\n     * @param opts - Options for the writer.\r\n     */\r\n    constructor(opts = {}) {\r\n        /** @internal */\r\n        this._currentIndentation = 0;\r\n        /** @internal */\r\n        this._length = 0;\r\n        /** @internal */\r\n        this._newLineOnNextWrite = false;\r\n        /** @internal */\r\n        this._currentCommentChar = undefined;\r\n        /** @internal */\r\n        this._stringCharStack = [];\r\n        /** @internal */\r\n        this._isInRegEx = false;\r\n        /** @internal */\r\n        this._isOnFirstLineOfBlock = true;\r\n        // An array of strings is used rather than a single string because it was\r\n        // found to be ~11x faster when printing a 10K line file (~11s to ~1s).\r\n        /** @internal */\r\n        this._texts = [];\r\n        this._newLine = opts.newLine || \"\\n\";\r\n        this._useTabs = opts.useTabs || false;\r\n        this._indentNumberOfSpaces = opts.indentNumberOfSpaces || 4;\r\n        this._indentationText = getIndentationText(this._useTabs, this._indentNumberOfSpaces);\r\n        this._quoteChar = opts.useSingleQuote ? \"'\" : `\"`;\r\n    }\r\n    /**\r\n     * Gets the options.\r\n     */\r\n    getOptions() {\r\n        return {\r\n            indentNumberOfSpaces: this._indentNumberOfSpaces,\r\n            newLine: this._newLine,\r\n            useTabs: this._useTabs,\r\n            useSingleQuote: this._quoteChar === \"'\",\r\n        };\r\n    }\r\n    queueIndentationLevel(countOrText) {\r\n        this._queuedIndentation = this._getIndentationLevelFromArg(countOrText);\r\n        this._queuedOnlyIfNotBlock = undefined;\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes the text within the provided action with hanging indentation.\r\n     * @param action - Action to perform with hanging indentation.\r\n     */\r\n    hangingIndent(action) {\r\n        return this._withResetIndentation(() => this.queueIndentationLevel(this.getIndentationLevel() + 1), action);\r\n    }\r\n    /**\r\n     * Writes the text within the provided action with hanging indentation unless writing a block.\r\n     * @param action - Action to perform with hanging indentation unless a block is written.\r\n     */\r\n    hangingIndentUnlessBlock(action) {\r\n        return this._withResetIndentation(() => {\r\n            this.queueIndentationLevel(this.getIndentationLevel() + 1);\r\n            this._queuedOnlyIfNotBlock = true;\r\n        }, action);\r\n    }\r\n    setIndentationLevel(countOrText) {\r\n        this._currentIndentation = this._getIndentationLevelFromArg(countOrText);\r\n        return this;\r\n    }\r\n    withIndentationLevel(countOrText, action) {\r\n        return this._withResetIndentation(() => this.setIndentationLevel(countOrText), action);\r\n    }\r\n    /** @internal */\r\n    _withResetIndentation(setStateAction, writeAction) {\r\n        const previousState = this._getIndentationState();\r\n        setStateAction();\r\n        try {\r\n            writeAction();\r\n        }\r\n        finally {\r\n            this._setIndentationState(previousState);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the current indentation level.\r\n     */\r\n    getIndentationLevel() {\r\n        return this._currentIndentation;\r\n    }\r\n    /**\r\n     * Writes a block using braces.\r\n     * @param block - Write using the writer within this block.\r\n     */\r\n    block(block) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (this.getLength() > 0 && !this.isLastNewLine())\r\n            this.spaceIfLastNot();\r\n        this.inlineBlock(block);\r\n        this._newLineOnNextWrite = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes an inline block with braces.\r\n     * @param block - Write using the writer within this block.\r\n     */\r\n    inlineBlock(block) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this.write(\"{\");\r\n        this._indentBlockInternal(block);\r\n        this.newLineIfLastNot().write(\"}\");\r\n        return this;\r\n    }\r\n    indent(timesOrBlock = 1) {\r\n        if (typeof timesOrBlock === \"number\") {\r\n            this._newLineIfNewLineOnNextWrite();\r\n            return this.write(this._indentationText.repeat(timesOrBlock));\r\n        }\r\n        else {\r\n            this._indentBlockInternal(timesOrBlock);\r\n            if (!this.isLastNewLine())\r\n                this._newLineOnNextWrite = true;\r\n            return this;\r\n        }\r\n    }\r\n    /** @internal */\r\n    _indentBlockInternal(block) {\r\n        if (this.getLastChar() != null)\r\n            this.newLineIfLastNot();\r\n        this._currentIndentation++;\r\n        this._isOnFirstLineOfBlock = true;\r\n        if (block != null)\r\n            block();\r\n        this._isOnFirstLineOfBlock = false;\r\n        this._currentIndentation = Math.max(0, this._currentIndentation - 1);\r\n    }\r\n    conditionalWriteLine(condition, strOrFunc) {\r\n        if (condition)\r\n            this.writeLine(stringUtils_1.getStringFromStrOrFunc(strOrFunc));\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a line of text.\r\n     * @param text - String to write.\r\n     */\r\n    writeLine(text) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (this.getLastChar() != null)\r\n            this.newLineIfLastNot();\r\n        this._writeIndentingNewLines(text);\r\n        this.newLine();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a newline if the last line was not a newline.\r\n     */\r\n    newLineIfLastNot() {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastNewLine())\r\n            this.newLine();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a blank line if the last written text was not a blank line.\r\n     */\r\n    blankLineIfLastNot() {\r\n        if (!this.isLastBlankLine())\r\n            this.blankLine();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a blank line if the condition is true.\r\n     * @param condition - Condition to evaluate.\r\n     */\r\n    conditionalBlankLine(condition) {\r\n        if (condition)\r\n            this.blankLine();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a blank line.\r\n     */\r\n    blankLine() {\r\n        return this.newLineIfLastNot().newLine();\r\n    }\r\n    /**\r\n     * Writes a newline if the condition is true.\r\n     * @param condition - Condition to evaluate.\r\n     */\r\n    conditionalNewLine(condition) {\r\n        if (condition)\r\n            this.newLine();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a newline.\r\n     */\r\n    newLine() {\r\n        this._newLineOnNextWrite = false;\r\n        this._baseWriteNewline();\r\n        return this;\r\n    }\r\n    quote(text) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(text == null ? this._quoteChar : this._quoteChar + stringUtils_1.escapeForWithinString(text, this._quoteChar) + this._quoteChar);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a space if the last character was not a space.\r\n     */\r\n    spaceIfLastNot() {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastSpace())\r\n            this._writeIndentingNewLines(\" \");\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a space.\r\n     * @param times - Number of times to write a space.\r\n     */\r\n    space(times = 1) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(\" \".repeat(times));\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a tab if the last character was not a tab.\r\n     */\r\n    tabIfLastNot() {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastTab())\r\n            this._writeIndentingNewLines(\"\\t\");\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a tab.\r\n     * @param times - Number of times to write a tab.\r\n     */\r\n    tab(times = 1) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(\"\\t\".repeat(times));\r\n        return this;\r\n    }\r\n    conditionalWrite(condition, textOrFunc) {\r\n        if (condition)\r\n            this.write(stringUtils_1.getStringFromStrOrFunc(textOrFunc));\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes the provided text.\r\n     * @param text - Text to write.\r\n     */\r\n    write(text) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(text);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes text to exit a comment if in a comment.\r\n     */\r\n    closeComment() {\r\n        const commentChar = this._currentCommentChar;\r\n        switch (commentChar) {\r\n            case CommentChar_1.CommentChar.Line:\r\n                this.newLine();\r\n                break;\r\n            case CommentChar_1.CommentChar.Star:\r\n                if (!this.isLastNewLine())\r\n                    this.spaceIfLastNot();\r\n                this.write(\"*/\");\r\n                break;\r\n            default:\r\n                const assertUndefined = commentChar;\r\n                break;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Inserts text at the provided position.\r\n     *\r\n     * This method is \"unsafe\" because it won't update the state of the writer unless\r\n     * inserting at the end position. It is biased towards being fast at inserting closer\r\n     * to the start or end, but slower to insert in the middle. Only use this if\r\n     * absolutely necessary.\r\n     * @param pos - Position to insert at.\r\n     * @param text - Text to insert.\r\n     */\r\n    unsafeInsert(pos, text) {\r\n        const textLength = this._length;\r\n        const texts = this._texts;\r\n        verifyInput();\r\n        if (pos === textLength)\r\n            return this.write(text);\r\n        updateInternalArray();\r\n        this._length += text.length;\r\n        return this;\r\n        function verifyInput() {\r\n            if (pos < 0)\r\n                throw new Error(`Provided position of '${pos}' was less than zero.`);\r\n            if (pos > textLength)\r\n                throw new Error(`Provided position of '${pos}' was greater than the text length of '${textLength}'.`);\r\n        }\r\n        function updateInternalArray() {\r\n            const { index, localIndex } = getArrayIndexAndLocalIndex();\r\n            if (localIndex === 0)\r\n                texts.splice(index, 0, text);\r\n            else if (localIndex === texts[index].length)\r\n                texts.splice(index + 1, 0, text);\r\n            else {\r\n                const textItem = texts[index];\r\n                const startText = textItem.substring(0, localIndex);\r\n                const endText = textItem.substring(localIndex);\r\n                texts.splice(index, 1, startText, text, endText);\r\n            }\r\n        }\r\n        function getArrayIndexAndLocalIndex() {\r\n            if (pos < textLength / 2) {\r\n                // start searching from the front\r\n                let endPos = 0;\r\n                for (let i = 0; i < texts.length; i++) {\r\n                    const textItem = texts[i];\r\n                    const startPos = endPos;\r\n                    endPos += textItem.length;\r\n                    if (endPos >= pos)\r\n                        return { index: i, localIndex: pos - startPos };\r\n                }\r\n            }\r\n            else {\r\n                // start searching from the back\r\n                let startPos = textLength;\r\n                for (let i = texts.length - 1; i >= 0; i--) {\r\n                    const textItem = texts[i];\r\n                    startPos -= textItem.length;\r\n                    if (startPos <= pos)\r\n                        return { index: i, localIndex: pos - startPos };\r\n                }\r\n            }\r\n            throw new Error(\"Unhandled situation inserting. This should never happen.\");\r\n        }\r\n    }\r\n    /**\r\n     * Gets the length of the string in the writer.\r\n     */\r\n    getLength() {\r\n        return this._length;\r\n    }\r\n    /**\r\n     * Gets if the writer is currently in a comment.\r\n     */\r\n    isInComment() {\r\n        return this._currentCommentChar !== undefined;\r\n    }\r\n    /**\r\n     * Gets if the writer is currently at the start of the first line of the text, block, or indentation block.\r\n     */\r\n    isAtStartOfFirstLineOfBlock() {\r\n        return this.isOnFirstLineOfBlock() && (this.isLastNewLine() || this.getLastChar() == null);\r\n    }\r\n    /**\r\n     * Gets if the writer is currently on the first line of the text, block, or indentation block.\r\n     */\r\n    isOnFirstLineOfBlock() {\r\n        return this._isOnFirstLineOfBlock;\r\n    }\r\n    /**\r\n     * Gets if the writer is currently in a string.\r\n     */\r\n    isInString() {\r\n        return this._stringCharStack.length > 0 && this._stringCharStack[this._stringCharStack.length - 1] !== CHARS.OPEN_BRACE;\r\n    }\r\n    /**\r\n     * Gets if the last chars written were for a newline.\r\n     */\r\n    isLastNewLine() {\r\n        const lastChar = this.getLastChar();\r\n        return lastChar === \"\\n\" || lastChar === \"\\r\";\r\n    }\r\n    /**\r\n     * Gets if the last chars written were for a blank line.\r\n     */\r\n    isLastBlankLine() {\r\n        let foundCount = 0;\r\n        // todo: consider extracting out iterating over past characters, but don't use\r\n        // an iterator because it will be slow.\r\n        for (let i = this._texts.length - 1; i >= 0; i--) {\r\n            const currentText = this._texts[i];\r\n            for (let j = currentText.length - 1; j >= 0; j--) {\r\n                const currentChar = currentText.charCodeAt(j);\r\n                if (currentChar === CHARS.NEW_LINE) {\r\n                    foundCount++;\r\n                    if (foundCount === 2)\r\n                        return true;\r\n                }\r\n                else if (currentChar !== CHARS.CARRIAGE_RETURN) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Gets if the last char written was a space.\r\n     */\r\n    isLastSpace() {\r\n        return this.getLastChar() === \" \";\r\n    }\r\n    /**\r\n     * Gets if the last char written was a tab.\r\n     */\r\n    isLastTab() {\r\n        return this.getLastChar() === \"\\t\";\r\n    }\r\n    /**\r\n     * Gets the last char written.\r\n     */\r\n    getLastChar() {\r\n        const charCode = this._getLastCharCodeWithOffset(0);\r\n        return charCode == null ? undefined : String.fromCharCode(charCode);\r\n    }\r\n    /**\r\n     * Gets if the writer ends with the provided text.\r\n     * @param text - Text to check if the writer ends with the provided text.\r\n     */\r\n    endsWith(text) {\r\n        const length = this._length;\r\n        return this.iterateLastCharCodes((charCode, index) => {\r\n            const offset = length - index;\r\n            const textIndex = text.length - offset;\r\n            if (text.charCodeAt(textIndex) !== charCode)\r\n                return false;\r\n            return textIndex === 0 ? true : undefined;\r\n        }) || false;\r\n    }\r\n    /**\r\n     * Iterates over the writer characters in reverse order. The iteration stops when a non-null or\r\n     * undefined value is returned from the action. The returned value is then returned by the method.\r\n     *\r\n     * @remarks It is much more efficient to use this method rather than `#toString()` since `#toString()`\r\n     * will combine the internal array into a string.\r\n     */\r\n    iterateLastChars(action) {\r\n        return this.iterateLastCharCodes((charCode, index) => action(String.fromCharCode(charCode), index));\r\n    }\r\n    /**\r\n     * Iterates over the writer character char codes in reverse order. The iteration stops when a non-null or\r\n     * undefined value is returned from the action. The returned value is then returned by the method.\r\n     *\r\n     * @remarks It is much more efficient to use this method rather than `#toString()` since `#toString()`\r\n     * will combine the internal array into a string. Additionally, this is slightly more efficient that\r\n     * `iterateLastChars` as this won't allocate a string per character.\r\n     */\r\n    iterateLastCharCodes(action) {\r\n        let index = this._length;\r\n        for (let i = this._texts.length - 1; i >= 0; i--) {\r\n            const currentText = this._texts[i];\r\n            for (let j = currentText.length - 1; j >= 0; j--) {\r\n                index--;\r\n                const result = action(currentText.charCodeAt(j), index);\r\n                if (result != null)\r\n                    return result;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Gets the writer's text.\r\n     */\r\n    toString() {\r\n        if (this._texts.length > 1) {\r\n            const text = this._texts.join(\"\");\r\n            this._texts.length = 0;\r\n            this._texts.push(text);\r\n        }\r\n        return this._texts[0] || \"\";\r\n    }\r\n    /** @internal */\r\n    _writeIndentingNewLines(text) {\r\n        text = text || \"\";\r\n        if (text.length === 0) {\r\n            writeIndividual(this, \"\");\r\n            return;\r\n        }\r\n        const items = text.split(CodeBlockWriter._newLineRegEx);\r\n        items.forEach((s, i) => {\r\n            if (i > 0)\r\n                this._baseWriteNewline();\r\n            if (s.length === 0)\r\n                return;\r\n            writeIndividual(this, s);\r\n        });\r\n        function writeIndividual(writer, s) {\r\n            if (!writer.isInString()) {\r\n                const isAtStartOfLine = writer.isLastNewLine() || writer.getLastChar() == null;\r\n                if (isAtStartOfLine)\r\n                    writer._writeIndentation();\r\n            }\r\n            writer._updateInternalState(s);\r\n            writer._internalWrite(s);\r\n        }\r\n    }\r\n    /** @internal */\r\n    _baseWriteNewline() {\r\n        if (this._currentCommentChar === CommentChar_1.CommentChar.Line)\r\n            this._currentCommentChar = undefined;\r\n        const lastStringCharOnStack = this._stringCharStack[this._stringCharStack.length - 1];\r\n        if ((lastStringCharOnStack === CHARS.DOUBLE_QUOTE || lastStringCharOnStack === CHARS.SINGLE_QUOTE) && this._getLastCharCodeWithOffset(0) !== CHARS.BACK_SLASH)\r\n            this._stringCharStack.pop();\r\n        this._internalWrite(this._newLine);\r\n        this._isOnFirstLineOfBlock = false;\r\n        this._dequeueQueuedIndentation();\r\n    }\r\n    /** @internal */\r\n    _dequeueQueuedIndentation() {\r\n        if (this._queuedIndentation == null)\r\n            return;\r\n        if (this._queuedOnlyIfNotBlock && wasLastBlock(this)) {\r\n            this._queuedIndentation = undefined;\r\n            this._queuedOnlyIfNotBlock = undefined;\r\n        }\r\n        else {\r\n            this._currentIndentation = this._queuedIndentation;\r\n            this._queuedIndentation = undefined;\r\n        }\r\n        function wasLastBlock(writer) {\r\n            let foundNewLine = false;\r\n            return writer.iterateLastCharCodes(charCode => {\r\n                switch (charCode) {\r\n                    case CHARS.NEW_LINE:\r\n                        if (foundNewLine)\r\n                            return false;\r\n                        else\r\n                            foundNewLine = true;\r\n                        break;\r\n                    case CHARS.CARRIAGE_RETURN:\r\n                        return undefined;\r\n                    case CHARS.OPEN_BRACE:\r\n                        return true;\r\n                    default:\r\n                        return false;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** @internal */\r\n    _updateInternalState(str) {\r\n        for (let i = 0; i < str.length; i++) {\r\n            const currentChar = str.charCodeAt(i);\r\n            // This is a performance optimization to short circuit all the checks below. If the current char\r\n            // is not in this set then it won't change any internal state so no need to continue and do\r\n            // so many other checks (this made it 3x faster in one scenario I tested).\r\n            if (!isCharToHandle.has(currentChar))\r\n                continue;\r\n            const pastChar = i === 0 ? this._getLastCharCodeWithOffset(0) : str.charCodeAt(i - 1);\r\n            const pastPastChar = i === 0 ? this._getLastCharCodeWithOffset(1) : i === 1 ? this._getLastCharCodeWithOffset(0) : str.charCodeAt(i - 2);\r\n            // handle regex\r\n            if (this._isInRegEx) {\r\n                if (pastChar === CHARS.FORWARD_SLASH && pastPastChar !== CHARS.BACK_SLASH || pastChar === CHARS.NEW_LINE)\r\n                    this._isInRegEx = false;\r\n                else\r\n                    continue;\r\n            }\r\n            else if (!this.isInString() && !this.isInComment() && isRegExStart(currentChar, pastChar, pastPastChar)) {\r\n                this._isInRegEx = true;\r\n                continue;\r\n            }\r\n            // handle comments\r\n            if (this._currentCommentChar == null && pastChar === CHARS.FORWARD_SLASH && currentChar === CHARS.FORWARD_SLASH)\r\n                this._currentCommentChar = CommentChar_1.CommentChar.Line;\r\n            else if (this._currentCommentChar == null && pastChar === CHARS.FORWARD_SLASH && currentChar === CHARS.ASTERISK)\r\n                this._currentCommentChar = CommentChar_1.CommentChar.Star;\r\n            else if (this._currentCommentChar === CommentChar_1.CommentChar.Star && pastChar === CHARS.ASTERISK && currentChar === CHARS.FORWARD_SLASH)\r\n                this._currentCommentChar = undefined;\r\n            if (this.isInComment())\r\n                continue;\r\n            // handle strings\r\n            const lastStringCharOnStack = this._stringCharStack.length === 0 ? undefined : this._stringCharStack[this._stringCharStack.length - 1];\r\n            if (pastChar !== CHARS.BACK_SLASH && (currentChar === CHARS.DOUBLE_QUOTE || currentChar === CHARS.SINGLE_QUOTE || currentChar === CHARS.BACK_TICK)) {\r\n                if (lastStringCharOnStack === currentChar)\r\n                    this._stringCharStack.pop();\r\n                else if (lastStringCharOnStack === CHARS.OPEN_BRACE || lastStringCharOnStack === undefined)\r\n                    this._stringCharStack.push(currentChar);\r\n            }\r\n            else if (pastPastChar !== CHARS.BACK_SLASH && pastChar === CHARS.DOLLAR_SIGN && currentChar === CHARS.OPEN_BRACE && lastStringCharOnStack === CHARS.BACK_TICK)\r\n                this._stringCharStack.push(currentChar);\r\n            else if (currentChar === CHARS.CLOSE_BRACE && lastStringCharOnStack === CHARS.OPEN_BRACE)\r\n                this._stringCharStack.pop();\r\n        }\r\n    }\r\n    /** @internal - This is private, but exposed for testing. */\r\n    _getLastCharCodeWithOffset(offset) {\r\n        if (offset >= this._length || offset < 0)\r\n            return undefined;\r\n        for (let i = this._texts.length - 1; i >= 0; i--) {\r\n            const currentText = this._texts[i];\r\n            if (offset >= currentText.length)\r\n                offset -= currentText.length;\r\n            else\r\n                return currentText.charCodeAt(currentText.length - 1 - offset);\r\n        }\r\n        return undefined;\r\n    }\r\n    /** @internal */\r\n    _writeIndentation() {\r\n        const flooredIndentation = Math.floor(this._currentIndentation);\r\n        this._internalWrite(this._indentationText.repeat(flooredIndentation));\r\n        const overflow = this._currentIndentation - flooredIndentation;\r\n        if (this._useTabs) {\r\n            if (overflow > 0.5)\r\n                this._internalWrite(this._indentationText);\r\n        }\r\n        else {\r\n            const portion = Math.round(this._indentationText.length * overflow);\r\n            // build up the string first, then append it for performance reasons\r\n            let text = \"\";\r\n            for (let i = 0; i < portion; i++)\r\n                text += this._indentationText[i];\r\n            this._internalWrite(text);\r\n        }\r\n    }\r\n    /** @internal */\r\n    _newLineIfNewLineOnNextWrite() {\r\n        if (!this._newLineOnNextWrite)\r\n            return;\r\n        this._newLineOnNextWrite = false;\r\n        this.newLine();\r\n    }\r\n    /** @internal */\r\n    _internalWrite(text) {\r\n        if (text.length === 0)\r\n            return;\r\n        this._texts.push(text);\r\n        this._length += text.length;\r\n    }\r\n    /** @internal */\r\n    _getIndentationLevelFromArg(countOrText) {\r\n        if (typeof countOrText === \"number\") {\r\n            if (countOrText < 0)\r\n                throw new Error(\"Passed in indentation level should be greater than or equal to 0.\");\r\n            return countOrText;\r\n        }\r\n        else if (typeof countOrText === \"string\") {\r\n            if (!CodeBlockWriter._spacesOrTabsRegEx.test(countOrText))\r\n                throw new Error(\"Provided string must be empty or only contain spaces or tabs.\");\r\n            const { spacesCount, tabsCount } = getSpacesAndTabsCount(countOrText);\r\n            return tabsCount + spacesCount / this._indentNumberOfSpaces;\r\n        }\r\n        else {\r\n            throw new Error(\"Argument provided must be a string or number.\");\r\n        }\r\n    }\r\n    /** @internal */\r\n    _setIndentationState(state) {\r\n        this._currentIndentation = state.current;\r\n        this._queuedIndentation = state.queued;\r\n        this._queuedOnlyIfNotBlock = state.queuedOnlyIfNotBlock;\r\n    }\r\n    /** @internal */\r\n    _getIndentationState() {\r\n        return {\r\n            current: this._currentIndentation,\r\n            queued: this._queuedIndentation,\r\n            queuedOnlyIfNotBlock: this._queuedOnlyIfNotBlock,\r\n        };\r\n    }\r\n}\r\nexports.default = CodeBlockWriter;\r\n/** @internal */\r\nCodeBlockWriter._newLineRegEx = /\\r?\\n/;\r\n/** @internal */\r\nCodeBlockWriter._spacesOrTabsRegEx = /^[ \\t]*$/;\r\nfunction isRegExStart(currentChar, pastChar, pastPastChar) {\r\n    return pastChar === CHARS.FORWARD_SLASH\r\n        && currentChar !== CHARS.FORWARD_SLASH\r\n        && currentChar !== CHARS.ASTERISK\r\n        && pastPastChar !== CHARS.ASTERISK\r\n        && pastPastChar !== CHARS.FORWARD_SLASH;\r\n}\r\nfunction getIndentationText(useTabs, numberSpaces) {\r\n    if (useTabs)\r\n        return \"\\t\";\r\n    return Array(numberSpaces + 1).join(\" \");\r\n}\r\nfunction getSpacesAndTabsCount(str) {\r\n    let spacesCount = 0;\r\n    let tabsCount = 0;\r\n    for (const char of str) {\r\n        if (char === \" \")\r\n            spacesCount++;\r\n        else if (char === \"\\t\")\r\n            tabsCount++;\r\n    }\r\n    return { spacesCount, tabsCount };\r\n}\r\n","var unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nmodule.exports = _createForOfIteratorHelper;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getStringFromStrOrFunc = exports.escapeChar = exports.escapeForWithinString = void 0;\r\nconst newlineRegex = /(\\r?\\n)/g;\r\n/** @internal */\r\nfunction escapeForWithinString(str, quoteKind) {\r\n    return escapeChar(str, quoteKind).replace(newlineRegex, \"\\\\$1\");\r\n}\r\nexports.escapeForWithinString = escapeForWithinString;\r\n/** @internal */\r\nfunction escapeChar(str, char) {\r\n    if (char.length !== 1)\r\n        throw new Error(`Specified char must be one character long.`);\r\n    let result = \"\";\r\n    for (let i = 0; i < str.length; i++) {\r\n        if (str[i] === char)\r\n            result += \"\\\\\";\r\n        result += str[i];\r\n    }\r\n    return result;\r\n}\r\nexports.escapeChar = escapeChar;\r\n/** @internal */\r\nfunction getStringFromStrOrFunc(strOrFunc) {\r\n    return strOrFunc instanceof Function ? strOrFunc() : strOrFunc;\r\n}\r\nexports.getStringFromStrOrFunc = getStringFromStrOrFunc;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CommentChar = void 0;\r\n/** @internal */\r\nvar CommentChar;\r\n(function (CommentChar) {\r\n    CommentChar[CommentChar[\"Line\"] = 0] = \"Line\";\r\n    CommentChar[CommentChar[\"Star\"] = 1] = \"Star\";\r\n})(CommentChar = exports.CommentChar || (exports.CommentChar = {}));\r\n"],"sourceRoot":""}